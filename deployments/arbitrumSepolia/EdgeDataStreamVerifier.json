{
  "address": "0x95036CDA2eF4CC06587376Ce3E55FD614a5D39a7",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_trustedSigner",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "recoverError",
          "type": "uint256"
        }
      ],
      "name": "InvalidEdgeSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidEdgeSigner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidTrustedSignerAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "feedId",
          "type": "string"
        },
        {
          "internalType": "uint192",
          "name": "price",
          "type": "uint192"
        },
        {
          "internalType": "uint32",
          "name": "roundId",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "timestamp",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "bid",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "ask",
          "type": "uint256"
        },
        {
          "internalType": "int32",
          "name": "expo",
          "type": "int32"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "extractSigner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "trustedSigner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "verifyData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "feedId",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "bid",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "ask",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "timestamp",
              "type": "uint32"
            },
            {
              "internalType": "int32",
              "name": "expo",
              "type": "int32"
            }
          ],
          "internalType": "struct EdgeDataStreamVerifier.Report",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "feedId",
          "type": "string"
        },
        {
          "internalType": "uint192",
          "name": "price",
          "type": "uint192"
        },
        {
          "internalType": "uint32",
          "name": "roundId",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "timestamp",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "bid",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "ask",
          "type": "uint256"
        },
        {
          "internalType": "int32",
          "name": "expo",
          "type": "int32"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "verifySignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x7977fefed34fca4f3b8c9e8cd19c6727c5c136b5177a8e6a54f86c1ffe30657a",
  "receipt": {
    "to": null,
    "from": "0xCD9706B6B71fdC4351091B5b1D910cEe7Fde28D0",
    "contractAddress": "0x95036CDA2eF4CC06587376Ce3E55FD614a5D39a7",
    "transactionIndex": 4,
    "gasUsed": "592944",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf9bba186dbcc119b5fdec0ae280250bb39e3f08893e86b72321a139577b73d2e",
    "transactionHash": "0x7977fefed34fca4f3b8c9e8cd19c6727c5c136b5177a8e6a54f86c1ffe30657a",
    "logs": [],
    "blockNumber": 154651968,
    "cumulativeGasUsed": "984995",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x1C498E2FE362e489A5Aac71690f9121914e0d55e"
  ],
  "numDeployments": 2,
  "solcInputHash": "07bf2f0e3a43f9cd4003783abc3e8968",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedSigner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recoverError\",\"type\":\"uint256\"}],\"name\":\"InvalidEdgeSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEdgeSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTrustedSignerAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"feedId\",\"type\":\"string\"},{\"internalType\":\"uint192\",\"name\":\"price\",\"type\":\"uint192\"},{\"internalType\":\"uint32\",\"name\":\"roundId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ask\",\"type\":\"uint256\"},{\"internalType\":\"int32\",\"name\":\"expo\",\"type\":\"int32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"extractSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"verifyData\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"feedId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ask\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"int32\",\"name\":\"expo\",\"type\":\"int32\"}],\"internalType\":\"struct EdgeDataStreamVerifier.Report\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"feedId\",\"type\":\"string\"},{\"internalType\":\"uint192\",\"name\":\"price\",\"type\":\"uint192\"},{\"internalType\":\"uint32\",\"name\":\"roundId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ask\",\"type\":\"uint256\"},{\"internalType\":\"int32\",\"name\":\"expo\",\"type\":\"int32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verifySignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Constructor to set the trusted signer address\",\"params\":{\"_trustedSigner\":\"The address of the trusted signer\"}},\"extractSigner(string,uint192,uint32,uint32,uint256,uint256,int32,bytes)\":{\"details\":\"Extracts address that signed price feed message\",\"params\":{\"ask\":\"The best ask price\",\"bid\":\"The best bid price\",\"feedId\":\"The ID of the price feed (e.g., \\\"BTCUSD\\\")\",\"price\":\"The price value\",\"roundId\":\"The round ID\",\"signature\":\"The signature to verify\",\"timestamp\":\"The timestamp of the observation\"},\"returns\":{\"_0\":\"True if the signature is valid, false otherwise\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/oracle/EdgeDataStreamVerifier.sol\":\"EdgeDataStreamVerifier\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/error/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Errors {\\n    // AdlHandler errors\\n    error AdlNotRequired(int256 pnlToPoolFactor, uint256 maxPnlFactorForAdl);\\n    error InvalidAdl(int256 nextPnlToPoolFactor, int256 pnlToPoolFactor);\\n    error PnlOvercorrected(int256 nextPnlToPoolFactor, uint256 minPnlFactorForAdl);\\n\\n    // AdlUtils errors\\n    error InvalidSizeDeltaForAdl(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\\n    error AdlNotEnabled();\\n\\n    // AutoCancelUtils errors\\n    error MaxAutoCancelOrdersExceeded(uint256 count, uint256 maxAutoCancelOrders);\\n\\n    // Bank errors\\n    error SelfTransferNotSupported(address receiver);\\n    error InvalidNativeTokenSender(address msgSender);\\n\\n    // BaseHandler errors\\n    error RequestNotYetCancellable(uint256 requestAge, uint256 requestExpirationAge, string requestType);\\n\\n    // CallbackUtils errors\\n    error MaxCallbackGasLimitExceeded(uint256 callbackGasLimit, uint256 maxCallbackGasLimit);\\n    error InsufficientGasLeftForCallback(uint256 gasToBeForwarded, uint256 callbackGasLimit);\\n\\n    // Config errors\\n    error InvalidBaseKey(bytes32 baseKey);\\n    error ConfigValueExceedsAllowedRange(bytes32 baseKey, uint256 value);\\n    error InvalidClaimableFactor(uint256 value);\\n    error InvalidClaimableReductionFactor(uint256 value);\\n    error OracleProviderAlreadyExistsForToken(address token);\\n    error OracleProviderMinChangeDelayNotYetPassed(address token, address provider);\\n    error PriceFeedAlreadyExistsForToken(address token);\\n    error DataStreamIdAlreadyExistsForToken(address token);\\n    error MaxFundingFactorPerSecondLimitExceeded(uint256 maxFundingFactorPerSecond, uint256 limit);\\n    error InvalidPositionImpactPoolDistributionRate(uint256 distributionAmount, uint256 positionImpactPoolAmount);\\n    error MaxDataListLengthExceeded(uint256 dataLength, uint256 maxDataLength);\\n    error EmptyToken();\\n\\n    // ContributorHandler errors\\n    error InvalidSetContributorPaymentInput(uint256 tokensLength, uint256 amountsLength);\\n    error InvalidContributorToken(address token);\\n    error MaxTotalContributorTokenAmountExceeded(address token, uint256 totalAmount, uint256 maxTotalAmount);\\n    error MinContributorPaymentIntervalNotYetPassed(uint256 minPaymentInterval);\\n    error MinContributorPaymentIntervalBelowAllowedRange(uint256 interval);\\n    error InvalidSetMaxTotalContributorTokenAmountInput(uint256 tokensLength, uint256 amountsLength);\\n\\n    // Timelock errors\\n    error ActionAlreadySignalled();\\n    error ActionNotSignalled();\\n    error SignalTimeNotYetPassed(uint256 signalTime);\\n    error InvalidTimelockDelay(uint256 timelockDelay);\\n    error MaxTimelockDelayExceeded(uint256 timelockDelay);\\n    error InvalidFeeReceiver(address receiver);\\n    error InvalidOracleSigner(address signer);\\n    error InvalidHoldingAddress(address account);\\n    error EmptyPositionImpactWithdrawalAmount();\\n    error OraclePriceOutdated();\\n    error EmptyTarget();\\n\\n    // GlvDepositStoreUtils errors\\n    error GlvDepositNotFound(bytes32 key);\\n    // GlvShiftStoreUtils errors\\n    error GlvShiftNotFound(bytes32 key);\\n    // GlvWithdrawalStoreUtils errors\\n    error GlvWithdrawalNotFound(bytes32 key);\\n    // GlvDepositUtils errors\\n    error EmptyGlvDepositAmounts();\\n    error EmptyGlvMarketAmount();\\n    error EmptyGlvDeposit();\\n    error InvalidMinGlvTokensForFirstGlvDeposit(uint256 minGlvTokens, uint256 expectedMinGlvTokens);\\n    error InvalidReceiverForFirstGlvDeposit(address receiver, address expectedReceiver);\\n    // GlvWithdrawalUtils errors\\n    error EmptyGlvWithdrawal();\\n    error EmptyGlvWithdrawalAmount();\\n    // GlvUtils errors\\n    error EmptyGlv(address glv);\\n    error EmptyGlvTokenSupply();\\n    error GlvNegativeMarketPoolValue(address glv, address market);\\n    error GlvUnsupportedMarket(address glv, address market);\\n    error GlvDisabledMarket(address glv, address market);\\n    error GlvEnabledMarket(address glv, address market);\\n    error GlvNonZeroMarketBalance(address glv, address market);\\n    error GlvMaxMarketCountExceeded(address glv, uint256 glvMaxMarketCount);\\n    error GlvMaxMarketTokenBalanceUsdExceeded(address glv, address market, uint256 maxMarketTokenBalanceUsd, uint256 marketTokenBalanceUsd);\\n    error GlvMaxMarketTokenBalanceAmountExceeded(address glv, address market, uint256 maxMarketTokenBalanceAmount, uint256 marketTokenBalanceAmount);\\n    error GlvInsufficientMarketTokenBalance(address glv, address market, uint256 marketTokenBalance, uint256 marketTokenAmount);\\n    error GlvMarketAlreadyExists(address glv, address market);\\n    error GlvInvalidLongToken(address glv, address provided, address expected);\\n    error GlvInvalidShortToken(address glv, address provided, address expected);\\n    // GlvShiftUtils\\n    error GlvShiftMaxPriceImpactExceeded(uint256 effectivePriceImpactFactor, uint256 glvMaxShiftPriceImpactFactor);\\n    error GlvShiftIntervalNotYetPassed(uint256 currentTimestamp, uint256 lastGlvShiftExecutedAt, uint256 glvShiftMinInterval);\\n    // GlvFactory\\n    error GlvAlreadyExists(bytes32 salt, address glv);\\n    error GlvSymbolTooLong();\\n    error GlvNameTooLong();\\n    // GlvStoreUtils\\n    error GlvNotFound(address key);\\n\\n    // DepositStoreUtils errors\\n    error DepositNotFound(bytes32 key);\\n\\n    // DepositUtils errors\\n    error EmptyDeposit();\\n    error EmptyDepositAmounts();\\n\\n    // ExecuteDepositUtils errors\\n    error MinMarketTokens(uint256 received, uint256 expected);\\n    error EmptyDepositAmountsAfterSwap();\\n    error InvalidPoolValueForDeposit(int256 poolValue);\\n    error InvalidSwapOutputToken(address outputToken, address expectedOutputToken);\\n    error InvalidReceiverForFirstDeposit(address receiver, address expectedReceiver);\\n    error InvalidMinMarketTokensForFirstDeposit(uint256 minMarketTokens, uint256 expectedMinMarketTokens);\\n\\n    // ExternalHandler errors\\n    error ExternalCallFailed(bytes data);\\n    error InvalidExternalCallInput(uint256 targetsLength, uint256 dataListLength);\\n    error InvalidExternalReceiversInput(uint256 refundTokensLength, uint256 refundReceiversLength);\\n    error InvalidExternalCallTarget(address target);\\n\\n    // FeeBatchStoreUtils errors\\n    error FeeBatchNotFound(bytes32 key);\\n\\n    // FeeDistributor errors\\n    error InvalidFeeBatchTokenIndex(uint256 tokenIndex, uint256 feeBatchTokensLength);\\n    error InvalidAmountInForFeeBatch(uint256 amountIn, uint256 remainingAmount);\\n    error InvalidSwapPathForV1(address[] path, address bridgingToken);\\n\\n    // GlpMigrator errors\\n    error InvalidGlpAmount(uint256 totalGlpAmountToRedeem, uint256 totalGlpAmount);\\n    error InvalidExecutionFeeForMigration(uint256 totalExecutionFee, uint256 msgValue);\\n\\n    // GlvHandler errors\\n    error InvalidGlvDepositInitialLongToken(address initialLongToken);\\n    error InvalidGlvDepositInitialShortToken(address initialShortToken);\\n    error InvalidGlvDepositSwapPath(uint256 longTokenSwapPathLength, uint256 shortTokenSwapPathLength);\\n    error MinGlvTokens(uint256 received, uint256 expected);\\n\\n    // OrderHandler errors\\n    error OrderNotUpdatable(uint256 orderType);\\n    error InvalidKeeperForFrozenOrder(address keeper);\\n\\n    // FeatureUtils errors\\n    error DisabledFeature(bytes32 key);\\n\\n    // FeeHandler errors\\n    error InvalidBuybackToken(address buybackToken);\\n    error InvalidVersion(uint256 version);\\n    error InsufficientBuybackOutputAmount(address feeToken, address buybackToken, uint256 outputAmount, uint256 minOutputAmount);\\n    error BuybackAndFeeTokenAreEqual(address feeToken, address buybackToken);\\n    error AvailableFeeAmountIsZero(address feeToken, address buybackToken, uint256 availableFeeAmount);\\n    error MaxBuybackPriceAgeExceeded(uint256 priceTimestamp, uint256 buybackMaxPriceAge, uint256 currentTimestamp);\\n    error EmptyClaimFeesMarket();\\n\\n    // GasUtils errors\\n    error InsufficientExecutionFee(uint256 minExecutionFee, uint256 executionFee);\\n    error InsufficientWntAmountForExecutionFee(uint256 wntAmount, uint256 executionFee);\\n    error InsufficientExecutionGasForErrorHandling(uint256 startingGas, uint256 minHandleErrorGas);\\n    error InsufficientExecutionGas(uint256 startingGas, uint256 estimatedGasLimit, uint256 minAdditionalGasForExecution);\\n    error InsufficientHandleExecutionErrorGas(uint256 gas, uint256 minHandleExecutionErrorGas);\\n    error InsufficientGasForCancellation(uint256 gas, uint256 minHandleExecutionErrorGas);\\n    error InsufficientGasForAutoCancellation(uint256 gas, uint256 minHandleExecutionErrorGas);\\n    error InvalidExecutionFee(uint256 executionFee, uint256 minExecutionFee, uint256 maxExecutionFee);\\n    error EmptyRelayFeeAddress();\\n\\n    // MarketFactory errors\\n    error MarketAlreadyExists(bytes32 salt, address existingMarketAddress);\\n\\n    // MarketStoreUtils errors\\n    error MarketNotFound(address key);\\n\\n    // MarketUtils errors\\n    error EmptyMarket();\\n    error DisabledMarket(address market);\\n    error MaxSwapPathLengthExceeded(uint256 swapPathLengh, uint256 maxSwapPathLength);\\n    error InsufficientPoolAmount(uint256 poolAmount, uint256 amount);\\n    error InsufficientReserve(uint256 reservedUsd, uint256 maxReservedUsd);\\n    error InsufficientReserveForOpenInterest(uint256 reservedUsd, uint256 maxReservedUsd);\\n    error UnableToGetOppositeToken(address inputToken, address market);\\n    error UnexpectedTokenForVirtualInventory(address token, address market);\\n    error EmptyMarketTokenSupply();\\n    error InvalidSwapMarket(address market);\\n    error UnableToGetCachedTokenPrice(address token, address market);\\n    error CollateralAlreadyClaimed(uint256 adjustedClaimableAmount, uint256 claimedAmount);\\n    error OpenInterestCannotBeUpdatedForSwapOnlyMarket(address market);\\n    error MaxOpenInterestExceeded(uint256 openInterest, uint256 maxOpenInterest);\\n    error MaxPoolAmountExceeded(uint256 poolAmount, uint256 maxPoolAmount);\\n    error MaxPoolUsdForDepositExceeded(uint256 poolUsd, uint256 maxPoolUsdForDeposit);\\n    error UnexpectedBorrowingFactor(uint256 positionBorrowingFactor, uint256 cumulativeBorrowingFactor);\\n    error UnableToGetBorrowingFactorEmptyPoolUsd();\\n    error UnableToGetFundingFactorEmptyOpenInterest();\\n    error InvalidPositionMarket(address market);\\n    error InvalidCollateralTokenForMarket(address market, address token);\\n    error PnlFactorExceededForLongs(int256 pnlToPoolFactor, uint256 maxPnlFactor);\\n    error PnlFactorExceededForShorts(int256 pnlToPoolFactor, uint256 maxPnlFactor);\\n    error InvalidUiFeeFactor(uint256 uiFeeFactor, uint256 maxUiFeeFactor);\\n    error EmptyAddressInMarketTokenBalanceValidation(address market, address token);\\n    error InvalidMarketTokenBalance(address market, address token, uint256 balance, uint256 expectedMinBalance);\\n    error InvalidMarketTokenBalanceForCollateralAmount(address market, address token, uint256 balance, uint256 collateralAmount);\\n    error InvalidMarketTokenBalanceForClaimableFunding(address market, address token, uint256 balance, uint256 claimableFundingFeeAmount);\\n    error UnexpectedPoolValue(int256 poolValue);\\n\\n    // MarketPositionImpactUtils errors\\n    error InsufficientImpactPoolValueForWithdrawal(uint256 withdrawalAmount, uint256 poolValue, int256 totalPendingImpactAmount);\\n\\n    // Oracle errors\\n    error SequencerDown();\\n    error SequencerGraceDurationNotYetPassed(uint256 timeSinceUp, uint256 sequencerGraceDuration);\\n    error EmptyValidatedPrices(); // not used, kept for compatibility\\n    error InvalidOracleProvider(address provider);\\n    error InvalidOracleProviderForToken(address provider, address expectedProvider);\\n    error GmEmptySigner(uint256 signerIndex);\\n    error InvalidOracleSetPricesProvidersParam(uint256 tokensLength, uint256 providersLength);\\n    error InvalidOracleSetPricesDataParam(uint256 tokensLength, uint256 dataLength);\\n    error GmInvalidBlockNumber(uint256 minOracleBlockNumber, uint256 currentBlockNumber);\\n    error GmInvalidMinMaxBlockNumber(uint256 minOracleBlockNumber, uint256 maxOracleBlockNumber);\\n    error EmptyDataStreamFeedId(address token);\\n    error InvalidDataStreamFeedId(address token, bytes32 feedId, bytes32 expectedFeedId);\\n    error InvalidDataStreamBidAsk(address token, int192 bid, int192 ask);\\n    error InvalidDataStreamPrices(address token, int192 bid, int192 ask);\\n    error MaxPriceAgeExceeded(uint256 oracleTimestamp, uint256 currentTimestamp);\\n    error MaxOracleTimestampRangeExceeded(uint256 range, uint256 maxRange);\\n    error GmMinOracleSigners(uint256 oracleSigners, uint256 minOracleSigners);\\n    error GmMaxOracleSigners(uint256 oracleSigners, uint256 maxOracleSigners);\\n    error BlockNumbersNotSorted(uint256 minOracleBlockNumber, uint256 prevMinOracleBlockNumber);\\n    error GmMinPricesNotSorted(address token, uint256 price, uint256 prevPrice);\\n    error GmMaxPricesNotSorted(address token, uint256 price, uint256 prevPrice);\\n    error EmptyChainlinkPriceFeedMultiplier(address token);\\n    error EmptyDataStreamMultiplier(address token);\\n    error InvalidDataStreamSpreadReductionFactor(address token, uint256 spreadReductionFactor);\\n    error InvalidFeedPrice(address token, int256 price);\\n    error ChainlinkPriceFeedNotUpdated(address token, uint256 timestamp, uint256 heartbeatDuration);\\n    error GmMaxSignerIndex(uint256 signerIndex, uint256 maxSignerIndex);\\n    error InvalidGmOraclePrice(address token);\\n    error InvalidGmSignerMinMaxPrice(uint256 minPrice, uint256 maxPrice);\\n    error InvalidGmMedianMinMaxPrice(uint256 minPrice, uint256 maxPrice);\\n    error NonEmptyTokensWithPrices(uint256 tokensWithPricesLength);\\n    error InvalidMinMaxForPrice(address token, uint256 min, uint256 max);\\n    error EmptyChainlinkPriceFeed(address token);\\n    error PriceAlreadySet(address token, uint256 minPrice, uint256 maxPrice);\\n    error MaxRefPriceDeviationExceeded(\\n        address token,\\n        uint256 price,\\n        uint256 refPrice,\\n        uint256 maxRefPriceDeviationFactor\\n    );\\n    error InvalidBlockRangeSet(uint256 largestMinBlockNumber, uint256 smallestMaxBlockNumber);\\n    error EmptyChainlinkPaymentToken();\\n    error NonAtomicOracleProvider(address provider);\\n\\n    // OracleModule errors\\n    error InvalidPrimaryPricesForSimulation(uint256 primaryTokensLength, uint256 primaryPricesLength);\\n    error EndOfOracleSimulation();\\n\\n    // OracleUtils errors\\n    error InvalidGmSignature(address recoveredSigner, address expectedSigner);\\n\\n    error EmptyPrimaryPrice(address token);\\n\\n    error OracleTimestampsAreSmallerThanRequired(uint256 minOracleTimestamp, uint256 expectedTimestamp);\\n    error OracleTimestampsAreLargerThanRequestExpirationTime(uint256 maxOracleTimestamp, uint256 requestTimestamp, uint256 requestExpirationTime);\\n\\n    // BaseOrderUtils errors\\n    error EmptyOrder();\\n    error UnsupportedOrderType(uint256 orderType);\\n    error UnsupportedOrderTypeForAutoCancellation(uint256 orderType);\\n    error InvalidOrderPrices(\\n        uint256 primaryPriceMin,\\n        uint256 primaryPriceMax,\\n        uint256 triggerPrice,\\n        uint256 orderType\\n    );\\n    error EmptySizeDeltaInTokens();\\n    error PriceImpactLargerThanOrderSize(int256 priceImpactUsd, uint256 sizeDeltaUsd);\\n    error NegativeExecutionPrice(int256 executionPrice, uint256 price, uint256 positionSizeInUsd, int256 priceImpactUsd, uint256 sizeDeltaUsd);\\n    error OrderNotFulfillableAtAcceptablePrice(uint256 price, uint256 acceptablePrice);\\n    error OrderValidFromTimeNotReached(uint256 validFromTime, uint256 currentTimestamp);\\n\\n    // IncreaseOrderUtils errors\\n    error UnexpectedPositionState();\\n\\n    // OrderUtils errors\\n    error OrderTypeCannotBeCreated(uint256 orderType);\\n    error OrderAlreadyFrozen();\\n    error MaxTotalCallbackGasLimitForAutoCancelOrdersExceeded(uint256 totalCallbackGasLimit, uint256 maxTotalCallbackGasLimit);\\n    error InvalidReceiver(address receiver);\\n    error UnexpectedValidFromTime(uint256 orderType);\\n\\n    // OrderStoreUtils errors\\n    error OrderNotFound(bytes32 key);\\n\\n    // SwapOrderUtils errors\\n    error UnexpectedMarket();\\n\\n    // DecreasePositionCollateralUtils errors\\n    error InsufficientFundsToPayForCosts(uint256 remainingCostUsd, string step);\\n    error InvalidOutputToken(address tokenOut, address expectedTokenOut);\\n\\n    // DecreasePositionUtils errors\\n    error InvalidDecreaseOrderSize(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\\n    error UnableToWithdrawCollateral(int256 estimatedRemainingCollateralUsd);\\n    error InvalidDecreasePositionSwapType(uint256 decreasePositionSwapType);\\n    error PositionShouldNotBeLiquidated(\\n        string reason,\\n        int256 remainingCollateralUsd,\\n        int256 minCollateralUsd,\\n        int256 minCollateralUsdForLeverage\\n    );\\n\\n    // IncreasePositionUtils errors\\n    error InsufficientCollateralAmount(uint256 collateralAmount, int256 collateralDeltaAmount);\\n    error InsufficientCollateralUsd(int256 remainingCollateralUsd);\\n\\n    // PositionStoreUtils errors\\n    error PositionNotFound(bytes32 key);\\n\\n    // PositionUtils errors\\n    error LiquidatablePosition(\\n        string reason,\\n        int256 remainingCollateralUsd,\\n        int256 minCollateralUsd,\\n        int256 minCollateralUsdForLeverage\\n    );\\n\\n    error EmptyPosition();\\n    error InvalidPositionSizeValues(uint256 sizeInUsd, uint256 sizeInTokens);\\n    error MinPositionSize(uint256 positionSizeInUsd, uint256 minPositionSizeUsd);\\n\\n    // PositionPricingUtils errors\\n    error UsdDeltaExceedsLongOpenInterest(int256 usdDelta, uint256 longOpenInterest);\\n    error UsdDeltaExceedsShortOpenInterest(int256 usdDelta, uint256 shortOpenInterest);\\n\\n    // ShiftStoreUtils errors\\n    error ShiftNotFound(bytes32 key);\\n\\n    // ShiftUtils errors\\n    error EmptyShift();\\n    error EmptyShiftAmount();\\n    error ShiftFromAndToMarketAreEqual(address market);\\n    error LongTokensAreNotEqual(address fromMarketLongToken, address toMarketLongToken);\\n    error ShortTokensAreNotEqual(address fromMarketLongToken, address toMarketLongToken);\\n\\n    // SwapPricingUtils errors\\n    error UsdDeltaExceedsPoolValue(int256 usdDelta, uint256 poolUsd);\\n\\n    // RoleModule errors\\n    error Unauthorized(address msgSender, string role);\\n\\n    // RoleStore errors\\n    error ThereMustBeAtLeastOneRoleAdmin();\\n    error ThereMustBeAtLeastOneTimelockMultiSig();\\n\\n    // ExchangeRouter errors\\n    error InvalidClaimFundingFeesInput(uint256 marketsLength, uint256 tokensLength);\\n    error InvalidClaimCollateralInput(uint256 marketsLength, uint256 tokensLength, uint256 timeKeysLength);\\n    error InvalidClaimAffiliateRewardsInput(uint256 marketsLength, uint256 tokensLength);\\n    error InvalidClaimUiFeesInput(uint256 marketsLength, uint256 tokensLength);\\n\\n    // SwapUtils errors\\n    error InvalidTokenIn(address tokenIn, address market);\\n    error InsufficientOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\\n    error InsufficientSwapOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\\n    error DuplicatedMarketInSwapPath(address market);\\n    error SwapPriceImpactExceedsAmountIn(uint256 amountAfterFees, int256 negativeImpactAmount);\\n\\n    // SubaccountRouter errors\\n    error InvalidReceiverForSubaccountOrder(address receiver, address expectedReceiver);\\n    error InvalidCancellationReceiverForSubaccountOrder(address cancellationReceiver, address expectedCancellationReceiver);\\n\\n    // SubaccountUtils errors\\n    error SubaccountNotAuthorized(address account, address subaccount);\\n    error MaxSubaccountActionCountExceeded(address account, address subaccount, uint256 count, uint256 maxCount);\\n    error SubaccountApprovalExpired(address account, address subaccount, uint256 deadline, uint256 currentTimestamp);\\n    error SubaccountIntegrationIdDisabled(bytes32 integrationId);\\n\\n    // TokenUtils errors\\n    error TokenTransferError(address token, address receiver, uint256 amount);\\n    error EmptyHoldingAddress();\\n    // Note that Transfer is misspelled as Tranfer in the EmptyTokenTranferGasLimit error\\n    // some contracts with this error cannot be re-deployed so it has been left as is\\n    error EmptyTokenTranferGasLimit(address token);\\n\\n    // AccountUtils errors\\n    error EmptyAccount();\\n    error EmptyReceiver();\\n    error DataListLengthExceeded();\\n\\n    // Array errors\\n    error CompactedArrayOutOfBounds(\\n        uint256[] compactedValues,\\n        uint256 index,\\n        uint256 slotIndex,\\n        string label\\n    );\\n\\n    error ArrayOutOfBoundsUint256(\\n        uint256[] values,\\n        uint256 index,\\n        string label\\n    );\\n\\n    error ArrayOutOfBoundsBytes(\\n        bytes[] values,\\n        uint256 index,\\n        string label\\n    );\\n\\n    // WithdrawalHandler errors\\n    error SwapsNotAllowedForAtomicWithdrawal(uint256 longTokenSwapPathLength, uint256 shortTokenSwapPathLength);\\n\\n    // WithdrawalStoreUtils errors\\n    error WithdrawalNotFound(bytes32 key);\\n\\n    // WithdrawalUtils errors\\n    error EmptyWithdrawal();\\n    error EmptyWithdrawalAmount();\\n    error MinLongTokens(uint256 received, uint256 expected);\\n    error MinShortTokens(uint256 received, uint256 expected);\\n    error InsufficientMarketTokens(uint256 balance, uint256 expected);\\n    error InvalidPoolValueForWithdrawal(int256 poolValue);\\n\\n    // Uint256Mask errors\\n    error MaskIndexOutOfBounds(uint256 index, string label);\\n    error DuplicatedIndex(uint256 index, string label);\\n\\n    // Cast errors\\n    error Uint256AsBytesLengthExceeds32Bytes(uint256 length);\\n\\n    // ConfigSyncer errors\\n    error SyncConfigInvalidInputLengths(uint256 marketsLength, uint256 parametersLength);\\n    error SyncConfigUpdatesDisabledForMarket(address market);\\n    error SyncConfigUpdatesDisabledForParameter(string parameter);\\n    error SyncConfigUpdatesDisabledForMarketParameter(address market, string parameter);\\n    error SyncConfigInvalidMarketFromData(address market, address marketFromData);\\n\\n    // Reader errors\\n    error EmptyMarketPrice(address market);\\n\\n    // Multichain errors\\n    error InvalidTransferRequestsLength();\\n    error EmptyMultichainTransferInAmount(address account, address token);\\n    error EmptyMultichainTransferOutAmount(address account, address token);\\n    error InsufficientMultichainBalance(address account, address token, uint256 balance, uint256 amount);\\n    error InvalidSrcChainId(uint256 srcChainId);\\n    error InvalidDestinationChainId(uint256 desChainId);\\n    error TokenPermitsNotAllowedForMultichain();\\n    error InvalidMultichainProvider(address provider);\\n    error InvalidMultichainEndpoint(address endpoint);\\n    error UnableToPayOrderFee();\\n    error UnableToPayOrderFeeFromCollateral();\\n    error InvalidBridgeOutToken(address token);\\n    error InvalidMultichainAction();\\n    error InsufficientFee(uint256 feeProvided, uint256 feeRequired);\\n\\n    enum SignatureType {\\n        Call,\\n        SubaccountApproval\\n    }\\n\\n    // Gelato relay errors\\n    error InvalidSignature(string signatureType);\\n    // User sent incorrect fee token or incorrect swap path\\n    error UnexpectedRelayFeeTokenAfterSwap(address feeToken, address expectedFeeToken);\\n    error UnexpectedRelayFeeToken(address feeToken, address expectedFeeToken);\\n    // Contract received unsupported fee token from Gelato relay\\n    error UnsupportedRelayFeeToken(address feeToken, address expectedFeeToken);\\n    error InvalidPermitSpender(address spender, address expectedSpender);\\n    error InvalidUserNonce(uint256 storedUserNonce, uint256 userNonce);\\n    error SubaccountApprovalDeadlinePassed(uint256 currentTimestamp, uint256 deadline);\\n    error InvalidSubaccountApprovalNonce(uint256 storedNonce, uint256 nonce);\\n    error DeadlinePassed(uint256 currentTimestamp, uint256 deadline);\\n    error InsufficientRelayFee(uint256 requiredRelayFee, uint256 availableFeeAmount);\\n    error InvalidSubaccountApprovalSubaccount();\\n    error NonEmptyExternalCallsForSubaccountOrder();\\n\\n    // EventUtils error\\n    error EventItemNotFound(string key);\\n\\n    // EdgeOracle verifier errors\\n    error InvalidTrustedSignerAddress();\\n    error InvalidEdgeSigner();\\n    error InvalidEdgeSignature(uint256 recoverError);\\n    error InvalidEdgeDataStreamBidAsk(address token, uint256 bid, uint256 ask);\\n    error InvalidEdgeDataStreamPrices(address token, uint256 bid, uint256 ask);\\n    error InvalidEdgeDataStreamExpo(int256 expo);\\n    error RelayEmptyBatch();\\n    error RelayCalldataTooLong(uint256 calldataLength);\\n    error InvalidExternalCalls(uint256 sendTokensLength, uint256 sendAmountsLength);\\n    error MaxRelayFeeSwapForSubaccountExceeded(uint256 feeUsd, uint256 maxFeeUsd);\\n}\\n\",\"keccak256\":\"0x296f047a10a499806db5b4e88b636074aeef260d60b87e115c50df857228fff0\",\"license\":\"BUSL-1.1\"},\"contracts/oracle/EdgeDataStreamVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {Errors} from \\\"../error/Errors.sol\\\";\\nimport {Cast} from \\\"../utils/Cast.sol\\\";\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\ncontract EdgeDataStreamVerifier {\\n\\n    struct Report {\\n        bytes32 feedId;\\n        uint256 bid; // bid: min price, highest buy price\\n        uint256 ask; // ask: max price, lowest sell price\\n        uint32 timestamp;\\n        int32 expo; // precision of bid&ask (negative value)\\n    }\\n\\n    address public immutable trustedSigner;\\n\\n    /**\\n    * @dev Constructor to set the trusted signer address\\n    * @param _trustedSigner The address of the trusted signer\\n    */\\n    constructor(address _trustedSigner) {\\n        if (_trustedSigner == address(0)) {\\n            revert Errors.InvalidTrustedSignerAddress();\\n        }\\n        trustedSigner = _trustedSigner;\\n    }\\n\\n\\n    function verifyData(bytes calldata data) public view returns (Report memory) {\\n        (\\n            string memory feedId,\\n            uint192 price,\\n            uint32 roundId,\\n            uint32 timestamp,\\n            uint256 bid,\\n            uint256 ask,\\n            bytes memory signature,\\n            int32 expo\\n        ) = abi.decode(data, (string, uint192, uint32, uint32, uint256, uint256, bytes, int32));\\n\\n        if (!verifySignature(\\n            feedId, price, roundId, timestamp, bid, ask, expo,\\n            signature)) {\\n            revert Errors.InvalidEdgeSigner();\\n        }\\n        return Report(\\n            Cast.toBytes32(feedId),\\n            bid,\\n            ask,\\n            timestamp,\\n            expo\\n        );\\n    }\\n\\n    function verifySignature(\\n        string memory feedId,\\n        uint192 price,\\n        uint32 roundId,\\n        uint32 timestamp,\\n        uint256 bid,\\n        uint256 ask,\\n        int32 expo,\\n        bytes memory signature\\n    ) public view returns (bool) {\\n        return extractSigner(\\n            feedId,\\n            price,\\n            roundId,\\n            timestamp,\\n            bid,\\n            ask,\\n            expo,\\n            signature\\n        ) == trustedSigner;\\n    }\\n\\n    /**\\n     * @dev Extracts address that signed price feed message\\n     * @param feedId The ID of the price feed (e.g., \\\"BTCUSD\\\")\\n     * @param price The price value\\n     * @param roundId The round ID\\n     * @param timestamp The timestamp of the observation\\n     * @param bid The best bid price\\n     * @param ask The best ask price\\n     * @param signature The signature to verify\\n     * @return True if the signature is valid, false otherwise\\n     */\\n    function extractSigner(\\n        string memory feedId,\\n        uint192 price,\\n        uint32 roundId,\\n        uint32 timestamp,\\n        uint256 bid,\\n        uint256 ask,\\n        int32 expo,\\n        bytes memory signature\\n    ) public pure returns (address) {\\n        // Recreate the message that was signed\\n        bytes32 messageHash;\\n        {\\n            messageHash = getMessageHash(\\n                leftPadBytes(bytes(feedId), 32),\\n                Cast.uint192ToBytes(price),\\n                Cast.uint32ToBytes(roundId),\\n                Cast.uint32ToBytes(timestamp),\\n                Cast.uint256ToBytes(bid),\\n                Cast.uint256ToBytes(ask),\\n                Cast.int32ToBytes(- expo)\\n            );\\n        }\\n\\n        (address recovered, ECDSA.RecoverError recoverError) = ECDSA.tryRecover(messageHash, signature);\\n        if (recoverError != ECDSA.RecoverError.NoError) {\\n            revert Errors.InvalidEdgeSignature(uint(recoverError));\\n        }\\n\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Creates a hash of the serialized price data in the same format as server does\\n     */\\n    function getMessageHash(\\n        bytes memory feedId,\\n        bytes memory price,\\n        bytes memory roundId,\\n        bytes memory ts,\\n        bytes memory bid,\\n        bytes memory ask,\\n        bytes memory expo\\n    ) private pure returns (bytes32) {\\n\\n        // split one abi.encodePacked call into two to avoid stack too deep error\\n        bytes memory message = abi.encodePacked(\\n            feedId,\\n            price,\\n            expo\\n        );\\n        message = abi.encodePacked(message,\\n            roundId,\\n            ts,\\n            bid,\\n            ask\\n        );\\n\\n        return keccak256(message);\\n    }\\n\\n    /**\\n    * @dev Left-pads a byte array to the desired length, similar to common.LeftPadBytes in Go\\n    */\\n    function leftPadBytes(\\n        bytes memory data,\\n        uint256 length\\n    ) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(length);\\n\\n        // If data is longer than length, truncate it\\n        uint256 dataLength = data.length;\\n        if (dataLength > length) {\\n            dataLength = length;\\n        }\\n\\n        // Copy data to the end of the result\\n        for (uint256 i = 0; i < dataLength; i++) {\\n            result[length - dataLength + i] = data[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xb2a6a14da84ba34a111d37a387fc264954488b6bfcc4c9ae95a97c62d994c0e7\",\"license\":\"MIT\"},\"contracts/utils/Cast.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../error/Errors.sol\\\";\\n\\n/**\\n * @title Cast\\n * @dev Library for casting functions\\n */\\nlibrary Cast {\\n    function toBytes32(address value) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(value)));\\n    }\\n\\n    function toBytes32(string memory value) internal pure returns (bytes32 result) {\\n        bytes memory tempEmptyString = bytes(value);\\n        if (tempEmptyString.length == 0) {\\n            return 0x0;\\n        }\\n\\n        assembly {\\n            result := mload(add(value, 32))\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a bytes array to a uint256.\\n     * Handles cases where the uint256 stored in bytes is stored with or without padding.\\n     * @param uint256AsBytes The bytes array representing the uint256 value.\\n     * @return value The uint256 value obtained from the bytes array.\\n     */\\n    function bytesToUint256(bytes memory uint256AsBytes) internal pure returns (uint256) {\\n        uint256 length = uint256AsBytes.length;\\n\\n        if(length > 32) {\\n            revert Errors.Uint256AsBytesLengthExceeds32Bytes(length);\\n        }\\n\\n        if (length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 value;\\n\\n        assembly {\\n            value := mload(add(uint256AsBytes, 32))\\n        }\\n\\n        return value = value >> (8 * (32 - length));\\n    }\\n\\n    function uint256ToBytes(uint256 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n        return b;\\n    }\\n\\n    function uint192ToBytes(uint192 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n        return b;\\n    }\\n\\n    function uint32ToBytes(uint32 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n        return b;\\n    }\\n\\n    function int32ToBytes(int32 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n//        bytes memory expoBytes = new bytes(1);\\n//        if (x < 0) {\\n//            expoBytes[0] = bytes1(uint8(-x)); // Use absolute value, e.g., uint8(8) -> 0x08\\n//        } else {\\n//            expoBytes[0] = bytes1(uint8(x));\\n//        }\\n        assembly { mstore(add(b, 32), x) }\\n        return b;\\n//        return expoBytes;\\n    }\\n}\\n\",\"keccak256\":\"0x6517a575dcc80e47912efac82d44ba1d8a89e2c40f8eb2f753304f0535f7ae35\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50604051610a72380380610a7283398101604081905261002f91610067565b6001600160a01b03811661005657604051639e5d5cf360e01b815260040160405180910390fd5b6001600160a01b0316608052610097565b60006020828403121561007957600080fd5b81516001600160a01b038116811461009057600080fd5b9392505050565b6080516109b96100b960003960008181610107015261012d01526109b96000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c8063166a15191461005157806375c5ebb514610079578063d94d4f55146100d7578063f74d548014610102575b600080fd5b61006461005f366004610676565b610129565b60405190151581526020015b60405180910390f35b61008c61008736600461072f565b61017c565b6040516100709190600060a08201905082518252602083015160208301526040830151604083015263ffffffff6060840151166060830152608083015160030b608083015292915050565b6100ea6100e5366004610676565b610240565b6040516001600160a01b039091168152602001610070565b6100ea7f000000000000000000000000000000000000000000000000000000000000000081565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166101658a8a8a8a8a8a8a8a610240565b6001600160a01b0316149998505050505050505050565b6040805160a081018252600080825260208201819052918101829052606081018290526080810182905290808080808080806101ba8b8b018c6107a0565b975097509750975097509750975097506101da8888888888888789610129565b6101f757604051638a1cc36b60e01b815260040160405180910390fd5b6040518060a0016040528061020b8a610307565b81526020018581526020018481526020018663ffffffff1681526020018260030b815250985050505050505050505b92915050565b6000806102946102518b6020610326565b61025a8b610402565b6102638b610402565b61026c8b610402565b6102758b610402565b61027e8b610402565b61028f61028a8c61086f565b610402565b61042c565b90506000806102a38386610493565b909250905060008160048111156102bc576102bc610892565b146102f8578060048111156102d3576102d3610892565b60405163545e155f60e01b81526004016102ef91815260200190565b60405180910390fd5b509a9950505050505050505050565b80516000908290820361031d5750600092915050565b50506020015190565b60606000826001600160401b0381111561034257610342610592565b6040519080825280601f01601f19166020018201604052801561036c576020820181803683370190505b5084519091508381111561037d5750825b60005b818110156103f85785818151811061039a5761039a6108a8565b01602001516001600160f81b03191683826103b585896108be565b6103bf91906108d1565b815181106103cf576103cf6108a8565b60200101906001600160f81b031916908160001a905350806103f0816108e4565b915050610380565b5090949350505050565b60408051602080825281830190925260609160208201818036833750505060208101929092525090565b6000808888846040516020016104449392919061092d565b6040516020818303038152906040529050808787878760405160200161046e959493929190610954565b60408051808303601f1901815291905280516020909101209998505050505050505050565b60008082516041036104c95760208301516040840151606085015160001a6104bd878285856104d8565b945094505050506104d1565b506000905060025b9250929050565b6000806fa2a8918ca85bafe22016d0b997e4df60600160ff1b038311156105055750600090506003610589565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610559573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811661058257600060019250925050610589565b9150600090505b94509492505050565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126105b957600080fd5b81356001600160401b03808211156105d3576105d3610592565b604051601f8301601f19908116603f011681019082821181831017156105fb576105fb610592565b8160405283815286602085880101111561061457600080fd5b836020870160208301376000602085830101528094505050505092915050565b80356001600160c01b038116811461064b57600080fd5b919050565b803563ffffffff8116811461064b57600080fd5b8035600381900b811461064b57600080fd5b600080600080600080600080610100898b03121561069357600080fd5b88356001600160401b03808211156106aa57600080fd5b6106b68c838d016105a8565b99506106c460208c01610634565b98506106d260408c01610650565b97506106e060608c01610650565b965060808b0135955060a08b013594506106fc60c08c01610664565b935060e08b013591508082111561071257600080fd5b5061071f8b828c016105a8565b9150509295985092959890939650565b6000806020838503121561074257600080fd5b82356001600160401b038082111561075957600080fd5b818501915085601f83011261076d57600080fd5b81358181111561077c57600080fd5b86602082850101111561078e57600080fd5b60209290920196919550909350505050565b600080600080600080600080610100898b0312156107bd57600080fd5b88356001600160401b03808211156107d457600080fd5b6107e08c838d016105a8565b99506107ee60208c01610634565b98506107fc60408c01610650565b975061080a60608c01610650565b965060808b0135955060a08b0135945060c08b013591508082111561082e57600080fd5b5061083b8b828c016105a8565b92505061084a60e08a01610664565b90509295985092959890939650565b634e487b7160e01b600052601160045260246000fd5b60008160030b637fffffff19810361088957610889610859565b60000392915050565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b8181038181111561023a5761023a610859565b8082018082111561023a5761023a610859565b6000600182016108f6576108f6610859565b5060010190565b6000815160005b8181101561091e5760208185018101518683015201610904565b50600093019283525090919050565b600061094b61094561093f84886108fd565b866108fd565b846108fd565b95945050505050565b600061097861094561093f61097261096c868c6108fd565b8a6108fd565b886108fd565b97965050505050505056fea264697066735822122099f1b874d631add91b05c71132ebff8884a5bb16b80431102ca4eff8fffe0de164736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c8063166a15191461005157806375c5ebb514610079578063d94d4f55146100d7578063f74d548014610102575b600080fd5b61006461005f366004610676565b610129565b60405190151581526020015b60405180910390f35b61008c61008736600461072f565b61017c565b6040516100709190600060a08201905082518252602083015160208301526040830151604083015263ffffffff6060840151166060830152608083015160030b608083015292915050565b6100ea6100e5366004610676565b610240565b6040516001600160a01b039091168152602001610070565b6100ea7f000000000000000000000000000000000000000000000000000000000000000081565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166101658a8a8a8a8a8a8a8a610240565b6001600160a01b0316149998505050505050505050565b6040805160a081018252600080825260208201819052918101829052606081018290526080810182905290808080808080806101ba8b8b018c6107a0565b975097509750975097509750975097506101da8888888888888789610129565b6101f757604051638a1cc36b60e01b815260040160405180910390fd5b6040518060a0016040528061020b8a610307565b81526020018581526020018481526020018663ffffffff1681526020018260030b815250985050505050505050505b92915050565b6000806102946102518b6020610326565b61025a8b610402565b6102638b610402565b61026c8b610402565b6102758b610402565b61027e8b610402565b61028f61028a8c61086f565b610402565b61042c565b90506000806102a38386610493565b909250905060008160048111156102bc576102bc610892565b146102f8578060048111156102d3576102d3610892565b60405163545e155f60e01b81526004016102ef91815260200190565b60405180910390fd5b509a9950505050505050505050565b80516000908290820361031d5750600092915050565b50506020015190565b60606000826001600160401b0381111561034257610342610592565b6040519080825280601f01601f19166020018201604052801561036c576020820181803683370190505b5084519091508381111561037d5750825b60005b818110156103f85785818151811061039a5761039a6108a8565b01602001516001600160f81b03191683826103b585896108be565b6103bf91906108d1565b815181106103cf576103cf6108a8565b60200101906001600160f81b031916908160001a905350806103f0816108e4565b915050610380565b5090949350505050565b60408051602080825281830190925260609160208201818036833750505060208101929092525090565b6000808888846040516020016104449392919061092d565b6040516020818303038152906040529050808787878760405160200161046e959493929190610954565b60408051808303601f1901815291905280516020909101209998505050505050505050565b60008082516041036104c95760208301516040840151606085015160001a6104bd878285856104d8565b945094505050506104d1565b506000905060025b9250929050565b6000806fa2a8918ca85bafe22016d0b997e4df60600160ff1b038311156105055750600090506003610589565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610559573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811661058257600060019250925050610589565b9150600090505b94509492505050565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126105b957600080fd5b81356001600160401b03808211156105d3576105d3610592565b604051601f8301601f19908116603f011681019082821181831017156105fb576105fb610592565b8160405283815286602085880101111561061457600080fd5b836020870160208301376000602085830101528094505050505092915050565b80356001600160c01b038116811461064b57600080fd5b919050565b803563ffffffff8116811461064b57600080fd5b8035600381900b811461064b57600080fd5b600080600080600080600080610100898b03121561069357600080fd5b88356001600160401b03808211156106aa57600080fd5b6106b68c838d016105a8565b99506106c460208c01610634565b98506106d260408c01610650565b97506106e060608c01610650565b965060808b0135955060a08b013594506106fc60c08c01610664565b935060e08b013591508082111561071257600080fd5b5061071f8b828c016105a8565b9150509295985092959890939650565b6000806020838503121561074257600080fd5b82356001600160401b038082111561075957600080fd5b818501915085601f83011261076d57600080fd5b81358181111561077c57600080fd5b86602082850101111561078e57600080fd5b60209290920196919550909350505050565b600080600080600080600080610100898b0312156107bd57600080fd5b88356001600160401b03808211156107d457600080fd5b6107e08c838d016105a8565b99506107ee60208c01610634565b98506107fc60408c01610650565b975061080a60608c01610650565b965060808b0135955060a08b0135945060c08b013591508082111561082e57600080fd5b5061083b8b828c016105a8565b92505061084a60e08a01610664565b90509295985092959890939650565b634e487b7160e01b600052601160045260246000fd5b60008160030b637fffffff19810361088957610889610859565b60000392915050565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b8181038181111561023a5761023a610859565b8082018082111561023a5761023a610859565b6000600182016108f6576108f6610859565b5060010190565b6000815160005b8181101561091e5760208185018101518683015201610904565b50600093019283525090919050565b600061094b61094561093f84886108fd565b866108fd565b846108fd565b95945050505050565b600061097861094561093f61097261096c868c6108fd565b8a6108fd565b886108fd565b97965050505050505056fea264697066735822122099f1b874d631add91b05c71132ebff8884a5bb16b80431102ca4eff8fffe0de164736f6c63430008140033",
  "libraries": {},
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "Constructor to set the trusted signer address",
        "params": {
          "_trustedSigner": "The address of the trusted signer"
        }
      },
      "extractSigner(string,uint192,uint32,uint32,uint256,uint256,int32,bytes)": {
        "details": "Extracts address that signed price feed message",
        "params": {
          "ask": "The best ask price",
          "bid": "The best bid price",
          "feedId": "The ID of the price feed (e.g., \"BTCUSD\")",
          "price": "The price value",
          "roundId": "The round ID",
          "signature": "The signature to verify",
          "timestamp": "The timestamp of the observation"
        },
        "returns": {
          "_0": "True if the signature is valid, false otherwise"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}