{
  "address": "0x32c206D8eA6903C3Ca5BDEd94877C72d92BDE82a",
  "abi": [
    {
      "inputs": [],
      "name": "EmptyAccount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EmptyAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EmptyToken",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "InvalidParams",
      "type": "error"
    }
  ],
  "transactionHash": "0x321a1e54fee424d1682328d78ef1fdab95a558c75bc5cc4ce56107f173488d06",
  "receipt": {
    "to": null,
    "from": "0xE7BfFf2aB721264887230037940490351700a068",
    "contractAddress": "0x32c206D8eA6903C3Ca5BDEd94877C72d92BDE82a",
    "transactionIndex": 0,
    "gasUsed": "946099",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa26b01ac638a11e1620806f946ef3824c75eb31871ba81827b2b7c12ec40d4f3",
    "transactionHash": "0x321a1e54fee424d1682328d78ef1fdab95a558c75bc5cc4ce56107f173488d06",
    "logs": [],
    "blockNumber": 72099320,
    "cumulativeGasUsed": "946099",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "a8f08a50b1857f459bad4d5d99a5e97c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.29+commit.ab55807c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"EmptyAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"InvalidParams\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/claim/ClaimUtils.sol\":\"ClaimUtils\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x9f4357008a8f7d8c8bf5d48902e789637538d8c016be5766610901b4bba81514\",\"license\":\"MIT\"},\"contracts/claim/ClaimEventUtils.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../event/EventUtils.sol\\\";\\nimport \\\"../event/EventEmitter.sol\\\";\\nimport \\\"../utils/Cast.sol\\\";\\n\\nlibrary ClaimEventUtils {\\n    using EventUtils for EventUtils.AddressItems;\\n    using EventUtils for EventUtils.UintItems;\\n    using EventUtils for EventUtils.Bytes32Items;\\n\\n    // @dev emit a ClaimFundsDeposited event\\n    // @param eventEmitter the event emitter\\n    // @param account the account funds were deposited for\\n    // @param token the token that was deposited\\n    // @param distributionId the distribution id that was deposited\\n    // @param amount the amount that was deposited\\n    // @param nextAmount the updated total amount for the account\\n    function emitClaimFundsDeposited(\\n        EventEmitter eventEmitter,\\n        address account,\\n        address token,\\n        uint256 distributionId,\\n        uint256 amount,\\n        uint256 nextAmount\\n    ) internal {\\n        EventUtils.EventLogData memory eventData;\\n\\n        eventData.addressItems.initItems(2);\\n        eventData.addressItems.setItem(0, \\\"account\\\", account);\\n        eventData.addressItems.setItem(1, \\\"token\\\", token);\\n\\n        eventData.uintItems.initItems(3);\\n        eventData.uintItems.setItem(0, \\\"distributionId\\\", distributionId);\\n        eventData.uintItems.setItem(1, \\\"amount\\\", amount);\\n        eventData.uintItems.setItem(2, \\\"nextAmount\\\", nextAmount);\\n\\n        eventEmitter.emitEventLog2(\\\"ClaimFundsDeposited\\\", Cast.toBytes32(account), Cast.toBytes32(token), eventData);\\n    }\\n\\n    // @dev emit a ClaimFundsWithdrawn event\\n    // @param eventEmitter the event emitter\\n    // @param account the account that funds were withdrawn for\\n    // @param token the token that was withdrawn\\n    // @param distributionId the distribution id that was withdrawn\\n    // @param amount the amount that was withdrawn\\n    // @param receiver the address that received the funds\\n    function emitClaimFundsWithdrawn(\\n        EventEmitter eventEmitter,\\n        address account,\\n        address token,\\n        uint256 distributionId,\\n        uint256 amount,\\n        address receiver\\n    ) internal {\\n        EventUtils.EventLogData memory eventData;\\n\\n        eventData.addressItems.initItems(3);\\n        eventData.addressItems.setItem(0, \\\"account\\\", account);\\n        eventData.addressItems.setItem(1, \\\"token\\\", token);\\n        eventData.addressItems.setItem(2, \\\"receiver\\\", receiver);\\n\\n        eventData.uintItems.initItems(2);\\n        eventData.uintItems.setItem(0, \\\"distributionId\\\", distributionId);\\n        eventData.uintItems.setItem(1, \\\"amount\\\", amount);\\n\\n        eventEmitter.emitEventLog2(\\\"ClaimFundsWithdrawn\\\", Cast.toBytes32(account), Cast.toBytes32(token), eventData);\\n    }\\n\\n    // @dev emit a ClaimFundsClaimed event\\n    // this event is emitted when user claims funds and funds are transferred\\n    // from the claim vault to the receiver\\n    // @param eventEmitter the event emitter\\n    // @param account the account that claimed funds\\n    // @param receiver the address that received the funds\\n    // @param token the token that was claimed\\n    // @param distributionId the distribution id that was claimed\\n    // @param amount the amount that was claimed\\n    function emitClaimFundsClaimed(\\n        EventEmitter eventEmitter,\\n        address account,\\n        address receiver,\\n        address token,\\n        uint256 distributionId,\\n        uint256 amount\\n    ) internal {\\n        EventUtils.EventLogData memory eventData;\\n\\n        eventData.addressItems.initItems(3);\\n        eventData.addressItems.setItem(0, \\\"account\\\", account);\\n        eventData.addressItems.setItem(1, \\\"receiver\\\", receiver);\\n        eventData.addressItems.setItem(2, \\\"token\\\", token);\\n\\n        eventData.uintItems.initItems(2);\\n        eventData.uintItems.setItem(0, \\\"distributionId\\\", distributionId);\\n        eventData.uintItems.setItem(1, \\\"amount\\\", amount);\\n\\n        eventEmitter.emitEventLog2(\\\"ClaimFundsClaimed\\\", Cast.toBytes32(account), Cast.toBytes32(token), eventData);\\n    }\\n\\n    // @dev emit a ClaimFundsTransferred event\\n    // this event is emitted when funds are transferred from one account to another\\n    // it affects internal accounting of the claimable funds amount only\\n    // funds stay inside the claim vault\\n    // @param eventEmitter the event emitter\\n    // @param token the token that was transferred\\n    // @param distributionId the distribution id for the transfer\\n    // @param fromAccount the account that funds were transferred from\\n    // @param toAccount the account that funds were transferred to\\n    // @param amount the amount that was transferred\\n    // @param nextAmount the updated total amount for the recipient\\n    function emitClaimFundsTransferred(\\n        EventEmitter eventEmitter,\\n        address token,\\n        uint256 distributionId,\\n        address fromAccount,\\n        address toAccount,\\n        uint256 amount,\\n        uint256 nextAmount\\n    ) internal {\\n        EventUtils.EventLogData memory eventData;\\n\\n        eventData.addressItems.initItems(3);\\n        eventData.addressItems.setItem(0, \\\"fromAccount\\\", fromAccount);\\n        eventData.addressItems.setItem(1, \\\"toAccount\\\", toAccount);\\n        eventData.addressItems.setItem(2, \\\"token\\\", token);\\n\\n        eventData.uintItems.initItems(3);\\n        eventData.uintItems.setItem(0, \\\"distributionId\\\", distributionId);\\n        eventData.uintItems.setItem(1, \\\"amount\\\", amount);\\n        eventData.uintItems.setItem(2, \\\"nextAmount\\\", nextAmount);\\n\\n        eventEmitter.emitEventLog2(\\n            \\\"ClaimFundsTransferred\\\",\\n            Cast.toBytes32(fromAccount),\\n            Cast.toBytes32(toAccount),\\n            eventData\\n        );\\n    }\\n\\n    // @dev emit a ClaimTermsSet event\\n    // @param eventEmitter the event emitter\\n    // @param distributionId the distribution id for the terms\\n    // @param termsHash the hash of the terms string\\n    function emitClaimTermsSet(EventEmitter eventEmitter, uint256 distributionId, bytes32 termsHash) internal {\\n        EventUtils.EventLogData memory eventData;\\n\\n        eventData.uintItems.initItems(1);\\n        eventData.uintItems.setItem(0, \\\"distributionId\\\", distributionId);\\n\\n        eventData.bytes32Items.initItems(1);\\n        eventData.bytes32Items.setItem(0, \\\"termsHash\\\", termsHash);\\n\\n        eventEmitter.emitEventLog1(\\\"ClaimTermsSet\\\", bytes32(distributionId), eventData);\\n    }\\n\\n    // @dev emit a ClaimTermsRemoved event\\n    // @param eventEmitter the event emitter\\n    // @param distributionId the distribution id for the terms that were removed\\n    function emitClaimTermsRemoved(EventEmitter eventEmitter, uint256 distributionId) internal {\\n        EventUtils.EventLogData memory eventData;\\n\\n        eventData.uintItems.initItems(1);\\n        eventData.uintItems.setItem(0, \\\"distributionId\\\", distributionId);\\n\\n        eventEmitter.emitEventLog1(\\\"ClaimTermsRemoved\\\", bytes32(distributionId), eventData);\\n    }\\n}\\n\",\"keccak256\":\"0xa6e67b15ce919d08dc676b39fe37c89cde7240ddf8fd80e24fdfa36794ebbad3\",\"license\":\"BUSL-1.1\"},\"contracts/claim/ClaimUtils.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nimport \\\"../event/EventEmitter.sol\\\";\\nimport \\\"../data/DataStore.sol\\\";\\nimport \\\"../data/Keys.sol\\\";\\nimport \\\"../error/Errors.sol\\\";\\nimport \\\"./ClaimEventUtils.sol\\\";\\n\\nlibrary ClaimUtils {\\n    using SafeERC20 for IERC20;\\n\\n    struct DepositParam {\\n        address account;\\n        uint256 amount;\\n    }\\n\\n    function incrementClaims(\\n        DataStore dataStore,\\n        EventEmitter eventEmitter,\\n        address token,\\n        uint256 distributionId,\\n        DepositParam[] calldata params\\n    ) external returns (uint256) {\\n        if (params.length == 0) {\\n            revert Errors.InvalidParams(\\\"deposit params length is 0\\\");\\n        }\\n        _validateNonEmptyToken(token);\\n        _validateNonZeroDistributionId(distributionId);\\n\\n        uint256 totalTransferAmount;\\n\\n        for (uint256 i = 0; i < params.length; i++) {\\n            DepositParam memory param = params[i];\\n\\n            _validateNonEmptyAccount(param.account);\\n            if (param.amount == 0) {\\n                revert Errors.EmptyAmount();\\n            }\\n\\n            uint256 nextAmount = dataStore.incrementUint(\\n                Keys.claimableFundsAmountKey(param.account, token, distributionId),\\n                param.amount\\n            );\\n\\n            totalTransferAmount += param.amount;\\n\\n            ClaimEventUtils.emitClaimFundsDeposited(\\n                eventEmitter,\\n                param.account,\\n                token,\\n                distributionId,\\n                param.amount,\\n                nextAmount\\n            );\\n        }\\n\\n        return totalTransferAmount;\\n    }\\n\\n    function _validateNonZeroDistributionId(uint256 distributionId) internal pure {\\n        if (distributionId == 0) {\\n            revert Errors.InvalidParams(\\\"distributionId is 0\\\");\\n        }\\n    }\\n\\n    function _validateNonEmptyAccount(address account) internal pure {\\n        if (account == address(0)) {\\n            revert Errors.EmptyAccount();\\n        }\\n    }\\n\\n    function _validateNonEmptyToken(address token) internal pure {\\n        if (token == address(0)) {\\n            revert Errors.EmptyToken();\\n        }\\n    }\\n\\n    function _validateTotalClaimableFundsAmount(DataStore dataStore, address token, address claimVault) internal view {\\n        // invariant check\\n        uint256 totalAmountLeft = dataStore.getUint(Keys.totalClaimableFundsAmountKey(token));\\n        if (totalAmountLeft > IERC20(token).balanceOf(address(claimVault))) {\\n            revert Errors.InsufficientFunds(token);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd296efc4321395f08d3f809e7a5ec3ffb1265aeaffbccfdbc793833d303a1c5c\",\"license\":\"BUSL-1.1\"},\"contracts/data/DataStore.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../role/RoleModule.sol\\\";\\nimport \\\"../utils/Calc.sol\\\";\\n\\n// @title DataStore\\n// @dev DataStore for all general state values\\ncontract DataStore is RoleModule {\\n    using SafeCast for int256;\\n\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableValues for EnumerableSet.Bytes32Set;\\n    using EnumerableValues for EnumerableSet.AddressSet;\\n    using EnumerableValues for EnumerableSet.UintSet;\\n\\n    // store for uint values\\n    mapping(bytes32 => uint256) public uintValues;\\n    // store for int values\\n    mapping(bytes32 => int256) public intValues;\\n    // store for address values\\n    mapping(bytes32 => address) public addressValues;\\n    // store for bool values\\n    mapping(bytes32 => bool) public boolValues;\\n    // store for string values\\n    mapping(bytes32 => string) public stringValues;\\n    // store for bytes32 values\\n    mapping(bytes32 => bytes32) public bytes32Values;\\n\\n    // store for uint[] values\\n    mapping(bytes32 => uint256[]) public uintArrayValues;\\n    // store for int[] values\\n    mapping(bytes32 => int256[]) public intArrayValues;\\n    // store for address[] values\\n    mapping(bytes32 => address[]) public addressArrayValues;\\n    // store for bool[] values\\n    mapping(bytes32 => bool[]) public boolArrayValues;\\n    // store for string[] values\\n    mapping(bytes32 => string[]) public stringArrayValues;\\n    // store for bytes32[] values\\n    mapping(bytes32 => bytes32[]) public bytes32ArrayValues;\\n\\n    // store for bytes32 sets\\n    mapping(bytes32 => EnumerableSet.Bytes32Set) internal bytes32Sets;\\n    // store for address sets\\n    mapping(bytes32 => EnumerableSet.AddressSet) internal addressSets;\\n    // store for uint256 sets\\n    mapping(bytes32 => EnumerableSet.UintSet) internal uintSets;\\n\\n    constructor(RoleStore _roleStore) RoleModule(_roleStore) {}\\n\\n    // @dev get the uint value for the given key\\n    // @param key the key of the value\\n    // @return the uint value for the key\\n    function getUint(bytes32 key) external view returns (uint256) {\\n        return uintValues[key];\\n    }\\n\\n    // @dev set the uint value for the given key\\n    // @param key the key of the value\\n    // @param value the value to set\\n    // @return the uint value for the key\\n    function setUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\\n        uintValues[key] = value;\\n        return value;\\n    }\\n\\n    // @dev delete the uint value for the given key\\n    // @param key the key of the value\\n    function removeUint(bytes32 key) external onlyController {\\n        delete uintValues[key];\\n    }\\n\\n    // @dev add the input int value to the existing uint value\\n    // @param key the key of the value\\n    // @param value the input int value\\n    // @return the new uint value\\n    function applyDeltaToUint(bytes32 key, int256 value, string memory errorMessage) external onlyController returns (uint256) {\\n        uint256 currValue = uintValues[key];\\n        if (value < 0 && (-value).toUint256() > currValue) {\\n            revert(errorMessage);\\n        }\\n        uint256 nextUint = Calc.sumReturnUint256(currValue, value);\\n        uintValues[key] = nextUint;\\n        return nextUint;\\n    }\\n\\n    // @dev add the input uint value to the existing uint value\\n    // @param key the key of the value\\n    // @param value the input int value\\n    // @return the new uint value\\n    function applyDeltaToUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\\n        uint256 currValue = uintValues[key];\\n        uint256 nextUint = currValue + value;\\n        uintValues[key] = nextUint;\\n        return nextUint;\\n    }\\n\\n    // @dev add the input int value to the existing uint value, prevent the uint\\n    // value from becoming negative\\n    // @param key the key of the value\\n    // @param value the input int value\\n    // @return the new uint value\\n    function applyBoundedDeltaToUint(bytes32 key, int256 value) external onlyController returns (uint256) {\\n        uint256 uintValue = uintValues[key];\\n        if (value < 0 && (-value).toUint256() > uintValue) {\\n            uintValues[key] = 0;\\n            return 0;\\n        }\\n\\n        uint256 nextUint = Calc.sumReturnUint256(uintValue, value);\\n        uintValues[key] = nextUint;\\n        return nextUint;\\n    }\\n\\n    // @dev add the input uint value to the existing uint value\\n    // @param key the key of the value\\n    // @param value the input uint value\\n    // @return the new uint value\\n    function incrementUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\\n        uint256 nextUint = uintValues[key] + value;\\n        uintValues[key] = nextUint;\\n        return nextUint;\\n    }\\n\\n    // @dev subtract the input uint value from the existing uint value\\n    // @param key the key of the value\\n    // @param value the input uint value\\n    // @return the new uint value\\n    function decrementUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\\n        uint256 nextUint = uintValues[key] - value;\\n        uintValues[key] = nextUint;\\n        return nextUint;\\n    }\\n\\n    // @dev get the int value for the given key\\n    // @param key the key of the value\\n    // @return the int value for the key\\n    function getInt(bytes32 key) external view returns (int256) {\\n        return intValues[key];\\n    }\\n\\n    // @dev set the int value for the given key\\n    // @param key the key of the value\\n    // @param value the value to set\\n    // @return the int value for the key\\n    function setInt(bytes32 key, int256 value) external onlyController returns (int256) {\\n        intValues[key] = value;\\n        return value;\\n    }\\n\\n    function removeInt(bytes32 key) external onlyController {\\n        delete intValues[key];\\n    }\\n\\n    // @dev add the input int value to the existing int value\\n    // @param key the key of the value\\n    // @param value the input int value\\n    // @return the new int value\\n    function applyDeltaToInt(bytes32 key, int256 value) external onlyController returns (int256) {\\n        int256 nextInt = intValues[key] + value;\\n        intValues[key] = nextInt;\\n        return nextInt;\\n    }\\n\\n    // @dev add the input int value to the existing int value\\n    // @param key the key of the value\\n    // @param value the input int value\\n    // @return the new int value\\n    function incrementInt(bytes32 key, int256 value) external onlyController returns (int256) {\\n        int256 nextInt = intValues[key] + value;\\n        intValues[key] = nextInt;\\n        return nextInt;\\n    }\\n\\n    // @dev subtract the input int value from the existing int value\\n    // @param key the key of the value\\n    // @param value the input int value\\n    // @return the new int value\\n    function decrementInt(bytes32 key, int256 value) external onlyController returns (int256) {\\n        int256 nextInt = intValues[key] - value;\\n        intValues[key] = nextInt;\\n        return nextInt;\\n    }\\n\\n    // @dev get the address value for the given key\\n    // @param key the key of the value\\n    // @return the address value for the key\\n    function getAddress(bytes32 key) external view returns (address) {\\n        return addressValues[key];\\n    }\\n\\n    // @dev set the address value for the given key\\n    // @param key the key of the value\\n    // @param value the value to set\\n    // @return the address value for the key\\n    function setAddress(bytes32 key, address value) external onlyController returns (address) {\\n        addressValues[key] = value;\\n        return value;\\n    }\\n\\n    // @dev delete the address value for the given key\\n    // @param key the key of the value\\n    function removeAddress(bytes32 key) external onlyController {\\n        delete addressValues[key];\\n    }\\n\\n    // @dev get the bool value for the given key\\n    // @param key the key of the value\\n    // @return the bool value for the key\\n    function getBool(bytes32 key) external view returns (bool) {\\n        return boolValues[key];\\n    }\\n\\n    // @dev set the bool value for the given key\\n    // @param key the key of the value\\n    // @param value the value to set\\n    // @return the bool value for the key\\n    function setBool(bytes32 key, bool value) external onlyController returns (bool) {\\n        boolValues[key] = value;\\n        return value;\\n    }\\n\\n    // @dev delete the bool value for the given key\\n    // @param key the key of the value\\n    function removeBool(bytes32 key) external onlyController {\\n        delete boolValues[key];\\n    }\\n\\n    // @dev get the string value for the given key\\n    // @param key the key of the value\\n    // @return the string value for the key\\n    function getString(bytes32 key) external view returns (string memory) {\\n        return stringValues[key];\\n    }\\n\\n    // @dev set the string value for the given key\\n    // @param key the key of the value\\n    // @param value the value to set\\n    // @return the string value for the key\\n    function setString(bytes32 key, string memory value) external onlyController returns (string memory) {\\n        stringValues[key] = value;\\n        return value;\\n    }\\n\\n    // @dev delete the string value for the given key\\n    // @param key the key of the value\\n    function removeString(bytes32 key) external onlyController {\\n        delete stringValues[key];\\n    }\\n\\n    // @dev get the bytes32 value for the given key\\n    // @param key the key of the value\\n    // @return the bytes32 value for the key\\n    function getBytes32(bytes32 key) external view returns (bytes32) {\\n        return bytes32Values[key];\\n    }\\n\\n    // @dev set the bytes32 value for the given key\\n    // @param key the key of the value\\n    // @param value the value to set\\n    // @return the bytes32 value for the key\\n    function setBytes32(bytes32 key, bytes32 value) external onlyController returns (bytes32) {\\n        bytes32Values[key] = value;\\n        return value;\\n    }\\n\\n    // @dev delete the bytes32 value for the given key\\n    // @param key the key of the value\\n    function removeBytes32(bytes32 key) external onlyController {\\n        delete bytes32Values[key];\\n    }\\n\\n    // @dev get the uint array for the given key\\n    // @param key the key of the uint array\\n    // @return the uint array for the key\\n    function getUintArray(bytes32 key) external view returns (uint256[] memory) {\\n        return uintArrayValues[key];\\n    }\\n\\n    // @dev set the uint array for the given key\\n    // @param key the key of the uint array\\n    // @param value the value of the uint array\\n    function setUintArray(bytes32 key, uint256[] memory value) external onlyController {\\n        uintArrayValues[key] = value;\\n    }\\n\\n    // @dev delete the uint array for the given key\\n    // @param key the key of the uint array\\n    // @param value the value of the uint array\\n    function removeUintArray(bytes32 key) external onlyController {\\n        delete uintArrayValues[key];\\n    }\\n\\n    // @dev get the int array for the given key\\n    // @param key the key of the int array\\n    // @return the int array for the key\\n    function getIntArray(bytes32 key) external view returns (int256[] memory) {\\n        return intArrayValues[key];\\n    }\\n\\n    // @dev set the int array for the given key\\n    // @param key the key of the int array\\n    // @param value the value of the int array\\n    function setIntArray(bytes32 key, int256[] memory value) external onlyController {\\n        intArrayValues[key] = value;\\n    }\\n\\n    // @dev delete the int array for the given key\\n    // @param key the key of the int array\\n    // @param value the value of the int array\\n    function removeIntArray(bytes32 key) external onlyController {\\n        delete intArrayValues[key];\\n    }\\n\\n    // @dev get the address array for the given key\\n    // @param key the key of the address array\\n    // @return the address array for the key\\n    function getAddressArray(bytes32 key) external view returns (address[] memory) {\\n        return addressArrayValues[key];\\n    }\\n\\n    // @dev set the address array for the given key\\n    // @param key the key of the address array\\n    // @param value the value of the address array\\n    function setAddressArray(bytes32 key, address[] memory value) external onlyController {\\n        addressArrayValues[key] = value;\\n    }\\n\\n    // @dev delete the address array for the given key\\n    // @param key the key of the address array\\n    // @param value the value of the address array\\n    function removeAddressArray(bytes32 key) external onlyController {\\n        delete addressArrayValues[key];\\n    }\\n\\n    // @dev get the bool array for the given key\\n    // @param key the key of the bool array\\n    // @return the bool array for the key\\n    function getBoolArray(bytes32 key) external view returns (bool[] memory) {\\n        return boolArrayValues[key];\\n    }\\n\\n    // @dev set the bool array for the given key\\n    // @param key the key of the bool array\\n    // @param value the value of the bool array\\n    function setBoolArray(bytes32 key, bool[] memory value) external onlyController {\\n        boolArrayValues[key] = value;\\n    }\\n\\n    // @dev delete the bool array for the given key\\n    // @param key the key of the bool array\\n    // @param value the value of the bool array\\n    function removeBoolArray(bytes32 key) external onlyController {\\n        delete boolArrayValues[key];\\n    }\\n\\n    // @dev get the string array for the given key\\n    // @param key the key of the string array\\n    // @return the string array for the key\\n    function getStringArray(bytes32 key) external view returns (string[] memory) {\\n        return stringArrayValues[key];\\n    }\\n\\n    // @dev set the string array for the given key\\n    // @param key the key of the string array\\n    // @param value the value of the string array\\n    function setStringArray(bytes32 key, string[] memory value) external onlyController {\\n        stringArrayValues[key] = value;\\n    }\\n\\n    // @dev delete the string array for the given key\\n    // @param key the key of the string array\\n    // @param value the value of the string array\\n    function removeStringArray(bytes32 key) external onlyController {\\n        delete stringArrayValues[key];\\n    }\\n\\n    // @dev get the bytes32 array for the given key\\n    // @param key the key of the bytes32 array\\n    // @return the bytes32 array for the key\\n    function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) {\\n        return bytes32ArrayValues[key];\\n    }\\n\\n    // @dev set the bytes32 array for the given key\\n    // @param key the key of the bytes32 array\\n    // @param value the value of the bytes32 array\\n    function setBytes32Array(bytes32 key, bytes32[] memory value) external onlyController {\\n        bytes32ArrayValues[key] = value;\\n    }\\n\\n    // @dev delete the bytes32 array for the given key\\n    // @param key the key of the bytes32 array\\n    // @param value the value of the bytes32 array\\n    function removeBytes32Array(bytes32 key) external onlyController {\\n        delete bytes32ArrayValues[key];\\n    }\\n\\n    // @dev check whether the given value exists in the set\\n    // @param setKey the key of the set\\n    // @param value the value to check\\n    function containsBytes32(bytes32 setKey, bytes32 value) external view returns (bool) {\\n        return bytes32Sets[setKey].contains(value);\\n    }\\n\\n    // @dev get the length of the set\\n    // @param setKey the key of the set\\n    function getBytes32Count(bytes32 setKey) external view returns (uint256) {\\n        return bytes32Sets[setKey].length();\\n    }\\n\\n    // @dev get the values of the set in the given range\\n    // @param setKey the key of the set\\n    // @param the start of the range, values at the start index will be returned\\n    // in the result\\n    // @param the end of the range, values at the end index will not be returned\\n    // in the result\\n    function getBytes32ValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (bytes32[] memory) {\\n        return bytes32Sets[setKey].valuesAt(start, end);\\n    }\\n\\n    // @dev add the given value to the set\\n    // @param setKey the key of the set\\n    // @param value the value to add\\n    function addBytes32(bytes32 setKey, bytes32 value) external onlyController {\\n        bytes32Sets[setKey].add(value);\\n    }\\n\\n    // @dev remove the given value from the set\\n    // @param setKey the key of the set\\n    // @param value the value to remove\\n    function removeBytes32(bytes32 setKey, bytes32 value) external onlyController {\\n        bytes32Sets[setKey].remove(value);\\n    }\\n\\n    // @dev check whether the given value exists in the set\\n    // @param setKey the key of the set\\n    // @param value the value to check\\n    function containsAddress(bytes32 setKey, address value) external view returns (bool) {\\n        return addressSets[setKey].contains(value);\\n    }\\n\\n    // @dev get the length of the set\\n    // @param setKey the key of the set\\n    function getAddressCount(bytes32 setKey) external view returns (uint256) {\\n        return addressSets[setKey].length();\\n    }\\n\\n    // @dev get the values of the set in the given range\\n    // @param setKey the key of the set\\n    // @param the start of the range, values at the start index will be returned\\n    // in the result\\n    // @param the end of the range, values at the end index will not be returned\\n    // in the result\\n    function getAddressValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (address[] memory) {\\n        return addressSets[setKey].valuesAt(start, end);\\n    }\\n\\n    // @dev add the given value to the set\\n    // @param setKey the key of the set\\n    // @param value the value to add\\n    function addAddress(bytes32 setKey, address value) external onlyController {\\n        addressSets[setKey].add(value);\\n    }\\n\\n    // @dev remove the given value from the set\\n    // @param setKey the key of the set\\n    // @param value the value to remove\\n    function removeAddress(bytes32 setKey, address value) external onlyController {\\n        addressSets[setKey].remove(value);\\n    }\\n\\n    // @dev check whether the given value exists in the set\\n    // @param setKey the key of the set\\n    // @param value the value to check\\n    function containsUint(bytes32 setKey, uint256 value) external view returns (bool) {\\n        return uintSets[setKey].contains(value);\\n    }\\n\\n    // @dev get the length of the set\\n    // @param setKey the key of the set\\n    function getUintCount(bytes32 setKey) external view returns (uint256) {\\n        return uintSets[setKey].length();\\n    }\\n\\n    // @dev get the values of the set in the given range\\n    // @param setKey the key of the set\\n    // @param the start of the range, values at the start index will be returned\\n    // in the result\\n    // @param the end of the range, values at the end index will not be returned\\n    // in the result\\n    function getUintValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (uint256[] memory) {\\n        return uintSets[setKey].valuesAt(start, end);\\n    }\\n\\n    // @dev add the given value to the set\\n    // @param setKey the key of the set\\n    // @param value the value to add\\n    function addUint(bytes32 setKey, uint256 value) external onlyController {\\n        uintSets[setKey].add(value);\\n    }\\n\\n    // @dev remove the given value from the set\\n    // @param setKey the key of the set\\n    // @param value the value to remove\\n    function removeUint(bytes32 setKey, uint256 value) external onlyController {\\n        uintSets[setKey].remove(value);\\n    }\\n}\\n\",\"keccak256\":\"0x38684fbf5eaa5e5c4ae0d220b28b7ceb3ddd6be8d983f162ac4430e7479dd90c\",\"license\":\"BUSL-1.1\"},\"contracts/data/Keys.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\n// @title Keys\\n// @dev Keys for values in the DataStore\\nlibrary Keys {\\n    // @dev key for the address of the wrapped native token\\n    bytes32 public constant WNT = keccak256(abi.encode(\\\"WNT\\\"));\\n    // @dev key for the nonce value used in NonceUtils\\n    bytes32 public constant NONCE = keccak256(abi.encode(\\\"NONCE\\\"));\\n\\n    // @dev for sending received fees\\n    bytes32 public constant FEE_RECEIVER = keccak256(abi.encode(\\\"FEE_RECEIVER\\\"));\\n\\n    // @dev for holding tokens that could not be sent out\\n    bytes32 public constant HOLDING_ADDRESS = keccak256(abi.encode(\\\"HOLDING_ADDRESS\\\"));\\n    bytes32 public constant RELAY_FEE_ADDRESS = keccak256(abi.encode(\\\"RELAY_FEE_ADDRESS\\\"));\\n\\n    // @dev key for the minimum gas for execution error\\n    bytes32 public constant MIN_HANDLE_EXECUTION_ERROR_GAS = keccak256(abi.encode(\\\"MIN_HANDLE_EXECUTION_ERROR_GAS\\\"));\\n\\n    // @dev key for the minimum gas that should be forwarded for execution error handling\\n    bytes32 public constant MIN_HANDLE_EXECUTION_ERROR_GAS_TO_FORWARD = keccak256(abi.encode(\\\"MIN_HANDLE_EXECUTION_ERROR_GAS_TO_FORWARD\\\"));\\n\\n    // @dev key for the min additional gas for execution\\n    bytes32 public constant MIN_ADDITIONAL_GAS_FOR_EXECUTION = keccak256(abi.encode(\\\"MIN_ADDITIONAL_GAS_FOR_EXECUTION\\\"));\\n\\n    // @dev for a global reentrancy guard\\n    bytes32 public constant REENTRANCY_GUARD_STATUS = keccak256(abi.encode(\\\"REENTRANCY_GUARD_STATUS\\\"));\\n\\n    // @dev key for deposit fees\\n    bytes32 public constant DEPOSIT_FEE_TYPE = keccak256(abi.encode(\\\"DEPOSIT_FEE_TYPE\\\"));\\n    // @dev key for withdrawal fees\\n    bytes32 public constant WITHDRAWAL_FEE_TYPE = keccak256(abi.encode(\\\"WITHDRAWAL_FEE_TYPE\\\"));\\n    // @dev key for swap fees\\n    bytes32 public constant SWAP_FEE_TYPE = keccak256(abi.encode(\\\"SWAP_FEE_TYPE\\\"));\\n    bytes32 public constant ATOMIC_SWAP_FEE_TYPE = keccak256(abi.encode(\\\"ATOMIC_SWAP_FEE_TYPE\\\"));\\n    // @dev key for position fees\\n    bytes32 public constant POSITION_FEE_TYPE = keccak256(abi.encode(\\\"POSITION_FEE_TYPE\\\"));\\n    // @dev key for ui deposit fees\\n    bytes32 public constant UI_DEPOSIT_FEE_TYPE = keccak256(abi.encode(\\\"UI_DEPOSIT_FEE_TYPE\\\"));\\n    // @dev key for ui withdrawal fees\\n    bytes32 public constant UI_WITHDRAWAL_FEE_TYPE = keccak256(abi.encode(\\\"UI_WITHDRAWAL_FEE_TYPE\\\"));\\n    // @dev key for ui swap fees\\n    bytes32 public constant UI_SWAP_FEE_TYPE = keccak256(abi.encode(\\\"UI_SWAP_FEE_TYPE\\\"));\\n    // @dev key for ui position fees\\n    bytes32 public constant UI_POSITION_FEE_TYPE = keccak256(abi.encode(\\\"UI_POSITION_FEE_TYPE\\\"));\\n\\n    // @dev key for ui fee factor\\n    bytes32 public constant UI_FEE_FACTOR = keccak256(abi.encode(\\\"UI_FEE_FACTOR\\\"));\\n    // @dev key for max ui fee receiver factor\\n    bytes32 public constant MAX_UI_FEE_FACTOR = keccak256(abi.encode(\\\"MAX_UI_FEE_FACTOR\\\"));\\n\\n    // @dev key for the claimable fee amount\\n    bytes32 public constant CLAIMABLE_FEE_AMOUNT = keccak256(abi.encode(\\\"CLAIMABLE_FEE_AMOUNT\\\"));\\n    // @dev key for the claimable ui fee amount\\n    bytes32 public constant CLAIMABLE_UI_FEE_AMOUNT = keccak256(abi.encode(\\\"CLAIMABLE_UI_FEE_AMOUNT\\\"));\\n    // @dev key for the max number of auto cancel orders\\n    bytes32 public constant MAX_AUTO_CANCEL_ORDERS = keccak256(abi.encode(\\\"MAX_AUTO_CANCEL_ORDERS\\\"));\\n    // @dev key for the max total callback gas limit for auto cancel orders\\n    bytes32 public constant MAX_TOTAL_CALLBACK_GAS_LIMIT_FOR_AUTO_CANCEL_ORDERS = keccak256(abi.encode(\\\"MAX_TOTAL_CALLBACK_GAS_LIMIT_FOR_AUTO_CANCEL_ORDERS\\\"));\\n\\n    // @dev key for the market list\\n    bytes32 public constant MARKET_LIST = keccak256(abi.encode(\\\"MARKET_LIST\\\"));\\n\\n    // @dev key for the fee batch list\\n    bytes32 public constant FEE_BATCH_LIST = keccak256(abi.encode(\\\"FEE_BATCH_LIST\\\"));\\n\\n    // @dev key for the deposit list\\n    bytes32 public constant DEPOSIT_LIST = keccak256(abi.encode(\\\"DEPOSIT_LIST\\\"));\\n    // @dev key for the account deposit list\\n    bytes32 public constant ACCOUNT_DEPOSIT_LIST = keccak256(abi.encode(\\\"ACCOUNT_DEPOSIT_LIST\\\"));\\n\\n    // @dev key for the withdrawal list\\n    bytes32 public constant WITHDRAWAL_LIST = keccak256(abi.encode(\\\"WITHDRAWAL_LIST\\\"));\\n    // @dev key for the account withdrawal list\\n    bytes32 public constant ACCOUNT_WITHDRAWAL_LIST = keccak256(abi.encode(\\\"ACCOUNT_WITHDRAWAL_LIST\\\"));\\n\\n    // @dev key for the shift list\\n    bytes32 public constant SHIFT_LIST = keccak256(abi.encode(\\\"SHIFT_LIST\\\"));\\n    // @dev key for the account shift list\\n    bytes32 public constant ACCOUNT_SHIFT_LIST = keccak256(abi.encode(\\\"ACCOUNT_SHIFT_LIST\\\"));\\n\\n    bytes32 public constant GLV_LIST = keccak256(abi.encode(\\\"GLV_LIST\\\"));\\n    bytes32 public constant GLV_DEPOSIT_LIST = keccak256(abi.encode(\\\"GLV_DEPOSIT_LIST\\\"));\\n    bytes32 public constant GLV_SHIFT_LIST = keccak256(abi.encode(\\\"GLV_SHIFT_LIST\\\"));\\n    bytes32 public constant ACCOUNT_GLV_DEPOSIT_LIST = keccak256(abi.encode(\\\"ACCOUNT_GLV_DEPOSIT_LIST\\\"));\\n    bytes32 public constant GLV_WITHDRAWAL_LIST = keccak256(abi.encode(\\\"GLV_WITHDRAWAL_LIST\\\"));\\n    bytes32 public constant ACCOUNT_GLV_WITHDRAWAL_LIST = keccak256(abi.encode(\\\"ACCOUNT_GLV_WITHDRAWAL_LIST\\\"));\\n    bytes32 public constant GLV_SUPPORTED_MARKET_LIST = keccak256(abi.encode(\\\"GLV_SUPPORTED_MARKET_LIST\\\"));\\n\\n    // @dev key for the position list\\n    bytes32 public constant POSITION_LIST = keccak256(abi.encode(\\\"POSITION_LIST\\\"));\\n    // @dev key for the account position list\\n    bytes32 public constant ACCOUNT_POSITION_LIST = keccak256(abi.encode(\\\"ACCOUNT_POSITION_LIST\\\"));\\n\\n    // @dev key for the order list\\n    bytes32 public constant ORDER_LIST = keccak256(abi.encode(\\\"ORDER_LIST\\\"));\\n    // @dev key for the account order list\\n    bytes32 public constant ACCOUNT_ORDER_LIST = keccak256(abi.encode(\\\"ACCOUNT_ORDER_LIST\\\"));\\n\\n    // @dev key for the subaccount list\\n    bytes32 public constant SUBACCOUNT_LIST = keccak256(abi.encode(\\\"SUBACCOUNT_LIST\\\"));\\n\\n    // @dev key for the auto cancel order list\\n    bytes32 public constant AUTO_CANCEL_ORDER_LIST = keccak256(abi.encode(\\\"AUTO_CANCEL_ORDER_LIST\\\"));\\n\\n    // @dev key for is market disabled\\n    bytes32 public constant IS_MARKET_DISABLED = keccak256(abi.encode(\\\"IS_MARKET_DISABLED\\\"));\\n\\n    // @dev key for the max swap path length allowed\\n    bytes32 public constant MAX_SWAP_PATH_LENGTH = keccak256(abi.encode(\\\"MAX_SWAP_PATH_LENGTH\\\"));\\n    // @dev key used to store markets observed in a swap path, to ensure that a swap path contains unique markets\\n    bytes32 public constant SWAP_PATH_MARKET_FLAG = keccak256(abi.encode(\\\"SWAP_PATH_MARKET_FLAG\\\"));\\n    // @dev key used to store the min market tokens for the first deposit for a market\\n    bytes32 public constant MIN_MARKET_TOKENS_FOR_FIRST_DEPOSIT = keccak256(abi.encode(\\\"MIN_MARKET_TOKENS_FOR_FIRST_DEPOSIT\\\"));\\n\\n    bytes32 public constant CREATE_GLV_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\\\"CREATE_GLV_DEPOSIT_FEATURE_DISABLED\\\"));\\n    bytes32 public constant CANCEL_GLV_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\\\"CANCEL_GLV_DEPOSIT_FEATURE_DISABLED\\\"));\\n    bytes32 public constant EXECUTE_GLV_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\\\"EXECUTE_GLV_DEPOSIT_FEATURE_DISABLED\\\"));\\n\\n    bytes32 public constant CREATE_GLV_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\\\"CREATE_GLV_WITHDRAWAL_FEATURE_DISABLED\\\"));\\n    bytes32 public constant CANCEL_GLV_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\\\"CANCEL_GLV_WITHDRAWAL_FEATURE_DISABLED\\\"));\\n    bytes32 public constant EXECUTE_GLV_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\\\"EXECUTE_GLV_WITHDRAWAL_FEATURE_DISABLED\\\"));\\n\\n    bytes32 public constant CREATE_GLV_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\\\"CREATE_GLV_SHIFT_FEATURE_DISABLED\\\"));\\n    bytes32 public constant EXECUTE_GLV_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\\\"EXECUTE_GLV_SHIFT_FEATURE_DISABLED\\\"));\\n\\n    bytes32 public constant JIT_FEATURE_DISABLED = keccak256(abi.encode(\\\"JIT_FEATURE_DISABLED\\\"));\\n\\n    // @dev key for whether the create deposit feature is disabled\\n    bytes32 public constant CREATE_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\\\"CREATE_DEPOSIT_FEATURE_DISABLED\\\"));\\n    // @dev key for whether the cancel deposit feature is disabled\\n    bytes32 public constant CANCEL_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\\\"CANCEL_DEPOSIT_FEATURE_DISABLED\\\"));\\n    // @dev key for whether the execute deposit feature is disabled\\n    bytes32 public constant EXECUTE_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\\\"EXECUTE_DEPOSIT_FEATURE_DISABLED\\\"));\\n\\n    // @dev key for whether the create withdrawal feature is disabled\\n    bytes32 public constant CREATE_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\\\"CREATE_WITHDRAWAL_FEATURE_DISABLED\\\"));\\n    // @dev key for whether the cancel withdrawal feature is disabled\\n    bytes32 public constant CANCEL_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\\\"CANCEL_WITHDRAWAL_FEATURE_DISABLED\\\"));\\n    // @dev key for whether the execute withdrawal feature is disabled\\n    bytes32 public constant EXECUTE_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\\\"EXECUTE_WITHDRAWAL_FEATURE_DISABLED\\\"));\\n    // @dev key for whether the execute atomic withdrawal feature is disabled\\n    bytes32 public constant EXECUTE_ATOMIC_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\\\"EXECUTE_ATOMIC_WITHDRAWAL_FEATURE_DISABLED\\\"));\\n\\n    // @dev key for whether the create shift feature is disabled\\n    bytes32 public constant CREATE_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\\\"CREATE_SHIFT_FEATURE_DISABLED\\\"));\\n    // @dev key for whether the cancel shift feature is disabled\\n    bytes32 public constant CANCEL_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\\\"CANCEL_SHIFT_FEATURE_DISABLED\\\"));\\n    // @dev key for whether the execute shift feature is disabled\\n    bytes32 public constant EXECUTE_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\\\"EXECUTE_SHIFT_FEATURE_DISABLED\\\"));\\n\\n    // @dev key for whether the create order feature is disabled\\n    bytes32 public constant CREATE_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\\\"CREATE_ORDER_FEATURE_DISABLED\\\"));\\n    // @dev key for whether the execute order feature is disabled\\n    bytes32 public constant EXECUTE_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\\\"EXECUTE_ORDER_FEATURE_DISABLED\\\"));\\n    // @dev key for whether the execute adl feature is disabled\\n    // for liquidations, it can be disabled by using the EXECUTE_ORDER_FEATURE_DISABLED key with the Liquidation\\n    // order type, ADL orders have a MarketDecrease order type, so a separate key is needed to disable it\\n    bytes32 public constant EXECUTE_ADL_FEATURE_DISABLED = keccak256(abi.encode(\\\"EXECUTE_ADL_FEATURE_DISABLED\\\"));\\n    // @dev key for whether the update order feature is disabled\\n    bytes32 public constant UPDATE_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\\\"UPDATE_ORDER_FEATURE_DISABLED\\\"));\\n    // @dev key for whether the cancel order feature is disabled\\n    bytes32 public constant CANCEL_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\\\"CANCEL_ORDER_FEATURE_DISABLED\\\"));\\n\\n    bytes32 public constant CLAIM_FUNDING_FEES_FEATURE_DISABLED = keccak256(abi.encode(\\\"CLAIM_FUNDING_FEES_FEATURE_DISABLED\\\"));\\n    bytes32 public constant CLAIM_COLLATERAL_FEATURE_DISABLED = keccak256(abi.encode(\\\"CLAIM_COLLATERAL_FEATURE_DISABLED\\\"));\\n    bytes32 public constant CLAIM_AFFILIATE_REWARDS_FEATURE_DISABLED = keccak256(abi.encode(\\\"CLAIM_AFFILIATE_REWARDS_FEATURE_DISABLED\\\"));\\n    bytes32 public constant CLAIM_UI_FEES_FEATURE_DISABLED = keccak256(abi.encode(\\\"CLAIM_UI_FEES_FEATURE_DISABLED\\\"));\\n    bytes32 public constant SUBACCOUNT_FEATURE_DISABLED = keccak256(abi.encode(\\\"SUBACCOUNT_FEATURE_DISABLED\\\"));\\n    bytes32 public constant GASLESS_FEATURE_DISABLED = keccak256(abi.encode(\\\"GASLESS_FEATURE_DISABLED\\\"));\\n    bytes32 public constant GENERAL_CLAIM_FEATURE_DISABLED = keccak256(abi.encode(\\\"GENERAL_CLAIM_FEATURE_DISABLED\\\"));\\n\\n    // @dev key for the minimum required oracle signers for an oracle observation\\n    bytes32 public constant MIN_ORACLE_SIGNERS = keccak256(abi.encode(\\\"MIN_ORACLE_SIGNERS\\\"));\\n    // @dev key for the minimum block confirmations before blockhash can be excluded for oracle signature validation\\n    bytes32 public constant MIN_ORACLE_BLOCK_CONFIRMATIONS = keccak256(abi.encode(\\\"MIN_ORACLE_BLOCK_CONFIRMATIONS\\\"));\\n    // @dev key for the maximum usable oracle price age in seconds\\n    bytes32 public constant MAX_ORACLE_PRICE_AGE = keccak256(abi.encode(\\\"MAX_ORACLE_PRICE_AGE\\\"));\\n    // @dev key for the maximum usable atomic oracle price age in seconds\\n    bytes32 public constant MAX_ATOMIC_ORACLE_PRICE_AGE = keccak256(abi.encode(\\\"MAX_ATOMIC_ORACLE_PRICE_AGE\\\"));\\n    // @dev key for the maximum oracle timestamp range\\n    bytes32 public constant MAX_ORACLE_TIMESTAMP_RANGE = keccak256(abi.encode(\\\"MAX_ORACLE_TIMESTAMP_RANGE\\\"));\\n    // @dev key for the maximum oracle price deviation factor from the ref price\\n    bytes32 public constant MAX_ORACLE_REF_PRICE_DEVIATION_FACTOR = keccak256(abi.encode(\\\"MAX_ORACLE_REF_PRICE_DEVIATION_FACTOR\\\"));\\n    // @dev key for whether an oracle provider is enabled\\n    bytes32 public constant IS_ORACLE_PROVIDER_ENABLED = keccak256(abi.encode(\\\"IS_ORACLE_PROVIDER_ENABLED\\\"));\\n    // @dev key for whether an oracle provider can be used for atomic actions\\n    bytes32 public constant IS_ATOMIC_ORACLE_PROVIDER = keccak256(abi.encode(\\\"IS_ATOMIC_ORACLE_PROVIDER\\\"));\\n    // @dev key for oracle timestamp adjustment\\n    bytes32 public constant ORACLE_TIMESTAMP_ADJUSTMENT = keccak256(abi.encode(\\\"ORACLE_TIMESTAMP_ADJUSTMENT\\\"));\\n    // @dev key for oracle provider for token\\n    bytes32 public constant ORACLE_PROVIDER_FOR_TOKEN = keccak256(abi.encode(\\\"ORACLE_PROVIDER_FOR_TOKEN\\\"));\\n    // @dev key for oracle provider updated time\\n    bytes32 public constant ORACLE_PROVIDER_UPDATED_AT = keccak256(abi.encode(\\\"ORACLE_PROVIDER_UPDATED_AT\\\"));\\n    // @dev key for oracle provider same value delay\\n    bytes32 public constant ORACLE_PROVIDER_MIN_CHANGE_DELAY = keccak256(abi.encode(\\\"ORACLE_PROVIDER_MIN_CHANGE_DELAY\\\"));\\n    // @dev key for the chainlink payment token\\n    bytes32 public constant CHAINLINK_PAYMENT_TOKEN = keccak256(abi.encode(\\\"CHAINLINK_PAYMENT_TOKEN\\\"));\\n    // @dev key for the sequencer grace duration\\n    bytes32 public constant SEQUENCER_GRACE_DURATION = keccak256(abi.encode(\\\"SEQUENCER_GRACE_DURATION\\\"));\\n\\n    // @dev key for the percentage amount of position fees to be received\\n    bytes32 public constant POSITION_FEE_RECEIVER_FACTOR = keccak256(abi.encode(\\\"POSITION_FEE_RECEIVER_FACTOR\\\"));\\n    // @dev key for the percentage amount of liquidation fees to be received\\n    bytes32 public constant LIQUIDATION_FEE_RECEIVER_FACTOR = keccak256(abi.encode(\\\"LIQUIDATION_FEE_RECEIVER_FACTOR\\\"));\\n    // @dev key for the percentage amount of swap fees to be received\\n    bytes32 public constant SWAP_FEE_RECEIVER_FACTOR = keccak256(abi.encode(\\\"SWAP_FEE_RECEIVER_FACTOR\\\"));\\n    // @dev key for the percentage amount of borrowing fees to be received\\n    bytes32 public constant BORROWING_FEE_RECEIVER_FACTOR = keccak256(abi.encode(\\\"BORROWING_FEE_RECEIVER_FACTOR\\\"));\\n\\n    // @dev key for the base gas limit used when estimating execution fee\\n    bytes32 public constant ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode(\\\"ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1\\\"));\\n    // @dev key for the gas limit used for each oracle price when estimating execution fee\\n    bytes32 public constant ESTIMATED_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode(\\\"ESTIMATED_GAS_FEE_PER_ORACLE_PRICE\\\"));\\n    // @dev key for the multiplier used when estimating execution fee\\n    bytes32 public constant ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode(\\\"ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR\\\"));\\n\\n    // @dev key for the base gas limit used when calculating execution fee\\n    bytes32 public constant EXECUTION_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode(\\\"EXECUTION_GAS_FEE_BASE_AMOUNT_V2_1\\\"));\\n    // @dev key for the gas limit used for each oracle price\\n    bytes32 public constant EXECUTION_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode(\\\"EXECUTION_GAS_FEE_PER_ORACLE_PRICE\\\"));\\n    // @dev key for the multiplier used when calculating execution fee\\n    bytes32 public constant EXECUTION_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode(\\\"EXECUTION_GAS_FEE_MULTIPLIER_FACTOR\\\"));\\n\\n    // @dev key for the max execution fee multiplier\\n    bytes32 public constant MAX_EXECUTION_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode(\\\"MAX_EXECUTION_FEE_MULTIPLIER_FACTOR\\\"));\\n\\n    bytes32 public constant MAX_RELAY_FEE_SWAP_USD_FOR_SUBACCOUNT = keccak256(abi.encode(\\\"MAX_RELAY_FEE_SWAP_USD_FOR_SUBACCOUNT\\\"));\\n    bytes32 public constant GELATO_RELAY_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode(\\\"GELATO_RELAY_FEE_MULTIPLIER_FACTOR\\\"));\\n    bytes32 public constant GELATO_RELAY_FEE_BASE_AMOUNT = keccak256(abi.encode(\\\"GELATO_RELAY_FEE_BASE_AMOUNT\\\"));\\n    bytes32 public constant CREATE_DEPOSIT_GAS_LIMIT = keccak256(abi.encode(\\\"CREATE_DEPOSIT_GAS_LIMIT\\\"));\\n    bytes32 public constant DEPOSIT_GAS_LIMIT = keccak256(abi.encode(\\\"DEPOSIT_GAS_LIMIT\\\"));\\n    bytes32 public constant CREATE_WITHDRAWAL_GAS_LIMIT = keccak256(abi.encode(\\\"CREATE_WITHDRAWAL_GAS_LIMIT\\\"));\\n    bytes32 public constant WITHDRAWAL_GAS_LIMIT = keccak256(abi.encode(\\\"WITHDRAWAL_GAS_LIMIT\\\"));\\n    bytes32 public constant CREATE_GLV_DEPOSIT_GAS_LIMIT = keccak256(abi.encode(\\\"CREATE_GLV_DEPOSIT_GAS_LIMIT\\\"));\\n    bytes32 public constant GLV_DEPOSIT_GAS_LIMIT = keccak256(abi.encode(\\\"GLV_DEPOSIT_GAS_LIMIT\\\"));\\n    bytes32 public constant CREATE_GLV_WITHDRAWAL_GAS_LIMIT = keccak256(abi.encode(\\\"CREATE_GLV_WITHDRAWAL_GAS_LIMIT\\\"));\\n    bytes32 public constant GLV_WITHDRAWAL_GAS_LIMIT = keccak256(abi.encode(\\\"GLV_WITHDRAWAL_GAS_LIMIT\\\"));\\n    bytes32 public constant GLV_SHIFT_GAS_LIMIT = keccak256(abi.encode(\\\"GLV_SHIFT_GAS_LIMIT\\\"));\\n    bytes32 public constant GLV_PER_MARKET_GAS_LIMIT = keccak256(abi.encode(\\\"GLV_PER_MARKET_GAS_LIMIT\\\"));\\n    bytes32 public constant SHIFT_GAS_LIMIT = keccak256(abi.encode(\\\"SHIFT_GAS_LIMIT\\\"));\\n    bytes32 public constant SINGLE_SWAP_GAS_LIMIT = keccak256(abi.encode(\\\"SINGLE_SWAP_GAS_LIMIT\\\"));\\n    bytes32 public constant INCREASE_ORDER_GAS_LIMIT = keccak256(abi.encode(\\\"INCREASE_ORDER_GAS_LIMIT\\\"));\\n    bytes32 public constant DECREASE_ORDER_GAS_LIMIT = keccak256(abi.encode(\\\"DECREASE_ORDER_GAS_LIMIT\\\"));\\n    bytes32 public constant SWAP_ORDER_GAS_LIMIT = keccak256(abi.encode(\\\"SWAP_ORDER_GAS_LIMIT\\\"));\\n    bytes32 public constant SET_TRADER_REFERRAL_CODE_GAS_LIMIT = keccak256(abi.encode(\\\"SET_TRADER_REFERRAL_CODE_GAS_LIMIT\\\"));\\n    bytes32 public constant REGISTER_CODE_GAS_LIMIT = keccak256(abi.encode(\\\"REGISTER_CODE_GAS_LIMIT\\\"));\\n\\n    bytes32 public constant TOKEN_TRANSFER_GAS_LIMIT = keccak256(abi.encode(\\\"TOKEN_TRANSFER_GAS_LIMIT\\\"));\\n    bytes32 public constant NATIVE_TOKEN_TRANSFER_GAS_LIMIT = keccak256(abi.encode(\\\"NATIVE_TOKEN_TRANSFER_GAS_LIMIT\\\"));\\n\\n    bytes32 public constant REQUEST_EXPIRATION_TIME = keccak256(abi.encode(\\\"REQUEST_EXPIRATION_TIME\\\"));\\n\\n    bytes32 public constant MAX_CALLBACK_GAS_LIMIT = keccak256(abi.encode(\\\"MAX_CALLBACK_GAS_LIMIT\\\"));\\n    bytes32 public constant REFUND_EXECUTION_FEE_GAS_LIMIT = keccak256(abi.encode(\\\"REFUND_EXECUTION_FEE_GAS_LIMIT\\\"));\\n    bytes32 public constant SAVED_CALLBACK_CONTRACT = keccak256(abi.encode(\\\"SAVED_CALLBACK_CONTRACT\\\"));\\n\\n    // @dev key for the min collateral factor\\n    bytes32 public constant MIN_COLLATERAL_FACTOR = keccak256(abi.encode(\\\"MIN_COLLATERAL_FACTOR\\\"));\\n    // @dev key for the min collateral factor for open interest multiplier\\n    bytes32 public constant MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER = keccak256(abi.encode(\\\"MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER\\\"));\\n    // @dev key for the min allowed collateral in USD\\n    bytes32 public constant MIN_COLLATERAL_USD = keccak256(abi.encode(\\\"MIN_COLLATERAL_USD\\\"));\\n    // @dev key for the min allowed collateral factor which is using for some new markets to limit allowed leverage\\n    bytes32 public constant MIN_COLLATERAL_FACTOR_FOR_LIQUIDATION = keccak256(abi.encode(\\\"MIN_COLLATERAL_FACTOR_FOR_LIQUIDATION\\\"));\\n    // @dev key for the min allowed position size in USD\\n    bytes32 public constant MIN_POSITION_SIZE_USD = keccak256(abi.encode(\\\"MIN_POSITION_SIZE_USD\\\"));\\n\\n    bytes32 public constant VIRTUAL_TOKEN_ID = keccak256(abi.encode(\\\"VIRTUAL_TOKEN_ID\\\"));\\n    bytes32 public constant VIRTUAL_MARKET_ID = keccak256(abi.encode(\\\"VIRTUAL_MARKET_ID\\\"));\\n    bytes32 public constant VIRTUAL_INVENTORY_FOR_SWAPS = keccak256(abi.encode(\\\"VIRTUAL_INVENTORY_FOR_SWAPS\\\"));\\n    bytes32 public constant VIRTUAL_INVENTORY_FOR_POSITIONS = keccak256(abi.encode(\\\"VIRTUAL_INVENTORY_FOR_POSITIONS\\\"));\\n    bytes32 public constant VIRTUAL_INVENTORY_FOR_POSITIONS_IN_TOKENS = keccak256(abi.encode(\\\"VIRTUAL_INVENTORY_FOR_POSITIONS_IN_TOKENS\\\"));\\n\\n    // @dev key for the position impact factor\\n    bytes32 public constant POSITION_IMPACT_FACTOR = keccak256(abi.encode(\\\"POSITION_IMPACT_FACTOR\\\"));\\n    // @dev key for the position impact exponent factor\\n    bytes32 public constant POSITION_IMPACT_EXPONENT_FACTOR = keccak256(abi.encode(\\\"POSITION_IMPACT_EXPONENT_FACTOR\\\"));\\n    // @dev key for the max decrease position impact factor\\n    bytes32 public constant MAX_POSITION_IMPACT_FACTOR = keccak256(abi.encode(\\\"MAX_POSITION_IMPACT_FACTOR\\\"));\\n    // @dev key for the max position impact factor for liquidations\\n    bytes32 public constant MAX_POSITION_IMPACT_FACTOR_FOR_LIQUIDATIONS = keccak256(abi.encode(\\\"MAX_POSITION_IMPACT_FACTOR_FOR_LIQUIDATIONS\\\"));\\n    // @dev key for the position fee factor\\n    bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode(\\\"POSITION_FEE_FACTOR\\\"));\\n    bytes32 public constant PRO_TRADER_TIER = keccak256(abi.encode(\\\"PRO_TRADER_TIER\\\"));\\n    bytes32 public constant PRO_DISCOUNT_FACTOR = keccak256(abi.encode(\\\"PRO_DISCOUNT_FACTOR\\\"));\\n    // @dev key for the liquidation fee factor\\n    bytes32 public constant LIQUIDATION_FEE_FACTOR = keccak256(abi.encode(\\\"LIQUIDATION_FEE_FACTOR\\\"));\\n    // @dev key for the swap impact factor\\n    bytes32 public constant SWAP_IMPACT_FACTOR = keccak256(abi.encode(\\\"SWAP_IMPACT_FACTOR\\\"));\\n    // @dev key for the swap impact exponent factor\\n    bytes32 public constant SWAP_IMPACT_EXPONENT_FACTOR = keccak256(abi.encode(\\\"SWAP_IMPACT_EXPONENT_FACTOR\\\"));\\n    // @dev key for the swap fee factor\\n    bytes32 public constant SWAP_FEE_FACTOR = keccak256(abi.encode(\\\"SWAP_FEE_FACTOR\\\"));\\n    // @dev key for the atomic swap fee factor\\n    bytes32 public constant ATOMIC_SWAP_FEE_FACTOR = keccak256(abi.encode(\\\"ATOMIC_SWAP_FEE_FACTOR\\\"));\\n    bytes32 public constant ATOMIC_WITHDRAWAL_FEE_FACTOR = keccak256(abi.encode(\\\"ATOMIC_WITHDRAWAL_FEE_FACTOR\\\"));\\n    bytes32 public constant DEPOSIT_FEE_FACTOR = keccak256(abi.encode(\\\"DEPOSIT_FEE_FACTOR\\\"));\\n    bytes32 public constant WITHDRAWAL_FEE_FACTOR = keccak256(abi.encode(\\\"WITHDRAWAL_FEE_FACTOR\\\"));\\n    // @dev key for the oracle type\\n    bytes32 public constant ORACLE_TYPE = keccak256(abi.encode(\\\"ORACLE_TYPE\\\"));\\n    // @dev key for open interest\\n    bytes32 public constant OPEN_INTEREST = keccak256(abi.encode(\\\"OPEN_INTEREST\\\"));\\n    // @dev key for open interest in tokens\\n    bytes32 public constant OPEN_INTEREST_IN_TOKENS = keccak256(abi.encode(\\\"OPEN_INTEREST_IN_TOKENS\\\"));\\n    bytes32 public constant COLLATERAL_SUM = keccak256(abi.encode(\\\"COLLATERAL_SUM\\\"));\\n    bytes32 public constant MAX_COLLATERAL_SUM = keccak256(abi.encode(\\\"MAX_COLLATERAL_SUM\\\"));\\n    // @dev key for pool amount\\n    bytes32 public constant POOL_AMOUNT = keccak256(abi.encode(\\\"POOL_AMOUNT\\\"));\\n    // @dev key for max pool amount\\n    bytes32 public constant MAX_POOL_AMOUNT = keccak256(abi.encode(\\\"MAX_POOL_AMOUNT\\\"));\\n    // @dev key for max pool usd for deposit\\n    bytes32 public constant MAX_POOL_USD_FOR_DEPOSIT = keccak256(abi.encode(\\\"MAX_POOL_USD_FOR_DEPOSIT\\\"));\\n    // @dev key for max open interest\\n    bytes32 public constant MAX_OPEN_INTEREST = keccak256(abi.encode(\\\"MAX_OPEN_INTEREST\\\"));\\n    // @dev key for position impact pool amount\\n    bytes32 public constant POSITION_IMPACT_POOL_AMOUNT = keccak256(abi.encode(\\\"POSITION_IMPACT_POOL_AMOUNT\\\"));\\n    // @dev key for lent position impact pool amount\\n    bytes32 public constant LENT_POSITION_IMPACT_POOL_AMOUNT = keccak256(abi.encode(\\\"LENT_POSITION_IMPACT_POOL_AMOUNT\\\"));\\n    bytes32 public constant MAX_LENDABLE_IMPACT_FACTOR = keccak256(abi.encode(\\\"MAX_LENDABLE_IMPACT_FACTOR\\\"));\\n    bytes32 public constant MAX_LENDABLE_IMPACT_FACTOR_FOR_WITHDRAWALS = keccak256(abi.encode(\\\"MAX_LENDABLE_IMPACT_FACTOR_FOR_WITHDRAWALS\\\"));\\n    bytes32 public constant MAX_LENDABLE_IMPACT_USD = keccak256(abi.encode(\\\"MAX_LENDABLE_IMPACT_USD\\\"));\\n    // @dev key for total pending position impact amount\\n    bytes32 public constant TOTAL_PENDING_IMPACT_AMOUNT = keccak256(abi.encode(\\\"TOTAL_PENDING_IMPACT_AMOUNT\\\"));\\n    // @dev key for min position impact pool amount\\n    bytes32 public constant MIN_POSITION_IMPACT_POOL_AMOUNT = keccak256(abi.encode(\\\"MIN_POSITION_IMPACT_POOL_AMOUNT\\\"));\\n    // @dev key for position impact pool distribution rate\\n    bytes32 public constant POSITION_IMPACT_POOL_DISTRIBUTION_RATE = keccak256(abi.encode(\\\"POSITION_IMPACT_POOL_DISTRIBUTION_RATE\\\"));\\n    // @dev key for position impact pool distributed at\\n    bytes32 public constant POSITION_IMPACT_POOL_DISTRIBUTED_AT = keccak256(abi.encode(\\\"POSITION_IMPACT_POOL_DISTRIBUTED_AT\\\"));\\n    // @dev key for swap impact pool amount\\n    bytes32 public constant SWAP_IMPACT_POOL_AMOUNT = keccak256(abi.encode(\\\"SWAP_IMPACT_POOL_AMOUNT\\\"));\\n    // @dev key for price feed\\n    bytes32 public constant PRICE_FEED = keccak256(abi.encode(\\\"PRICE_FEED\\\"));\\n    // @dev key for price feed multiplier\\n    bytes32 public constant PRICE_FEED_MULTIPLIER = keccak256(abi.encode(\\\"PRICE_FEED_MULTIPLIER\\\"));\\n    // @dev key for price feed heartbeat\\n    bytes32 public constant PRICE_FEED_HEARTBEAT_DURATION = keccak256(abi.encode(\\\"PRICE_FEED_HEARTBEAT_DURATION\\\"));\\n    // @dev key for data stream feed id\\n    bytes32 public constant DATA_STREAM_ID = keccak256(abi.encode(\\\"DATA_STREAM_ID\\\"));\\n    bytes32 public constant EDGE_DATA_STREAM_ID = keccak256(abi.encode(\\\"EDGE_DATA_STREAM_ID\\\"));\\n    bytes32 public constant EDGE_DATA_STREAM_TOKEN_DECIMALS = keccak256(abi.encode(\\\"EDGE_DATA_STREAM_TOKEN_DECIMALS\\\"));\\n    // @dev key for data stream feed multiplier\\n    bytes32 public constant DATA_STREAM_MULTIPLIER = keccak256(abi.encode(\\\"DATA_STREAM_MULTIPLIER\\\"));\\n    bytes32 public constant DATA_STREAM_SPREAD_REDUCTION_FACTOR = keccak256(abi.encode(\\\"DATA_STREAM_SPREAD_REDUCTION_FACTOR\\\"));\\n    // @dev key for stable price\\n    bytes32 public constant STABLE_PRICE = keccak256(abi.encode(\\\"STABLE_PRICE\\\"));\\n    // @dev key for reserve factor\\n    bytes32 public constant RESERVE_FACTOR = keccak256(abi.encode(\\\"RESERVE_FACTOR\\\"));\\n    // @dev key for open interest reserve factor\\n    bytes32 public constant OPEN_INTEREST_RESERVE_FACTOR = keccak256(abi.encode(\\\"OPEN_INTEREST_RESERVE_FACTOR\\\"));\\n    // @dev key for max pnl factor\\n    bytes32 public constant MAX_PNL_FACTOR = keccak256(abi.encode(\\\"MAX_PNL_FACTOR\\\"));\\n    // @dev key for max pnl factor\\n    bytes32 public constant MAX_PNL_FACTOR_FOR_TRADERS = keccak256(abi.encode(\\\"MAX_PNL_FACTOR_FOR_TRADERS\\\"));\\n    // @dev key for max pnl factor for adl\\n    bytes32 public constant MAX_PNL_FACTOR_FOR_ADL = keccak256(abi.encode(\\\"MAX_PNL_FACTOR_FOR_ADL\\\"));\\n    // @dev key for min pnl factor for adl\\n    bytes32 public constant MIN_PNL_FACTOR_AFTER_ADL = keccak256(abi.encode(\\\"MIN_PNL_FACTOR_AFTER_ADL\\\"));\\n    // @dev key for max pnl factor\\n    bytes32 public constant MAX_PNL_FACTOR_FOR_DEPOSITS = keccak256(abi.encode(\\\"MAX_PNL_FACTOR_FOR_DEPOSITS\\\"));\\n    // @dev key for max pnl factor for withdrawals\\n    bytes32 public constant MAX_PNL_FACTOR_FOR_WITHDRAWALS = keccak256(abi.encode(\\\"MAX_PNL_FACTOR_FOR_WITHDRAWALS\\\"));\\n    // @dev key for latest ADL at\\n    bytes32 public constant LATEST_ADL_AT = keccak256(abi.encode(\\\"LATEST_ADL_AT\\\"));\\n    // @dev key for whether ADL is enabled\\n    bytes32 public constant IS_ADL_ENABLED = keccak256(abi.encode(\\\"IS_ADL_ENABLED\\\"));\\n    // @dev key for funding factor\\n    bytes32 public constant FUNDING_FACTOR = keccak256(abi.encode(\\\"FUNDING_FACTOR\\\"));\\n    // @dev key for funding exponent factor\\n    bytes32 public constant FUNDING_EXPONENT_FACTOR = keccak256(abi.encode(\\\"FUNDING_EXPONENT_FACTOR\\\"));\\n    // @dev key for saved funding factor\\n    bytes32 public constant SAVED_FUNDING_FACTOR_PER_SECOND = keccak256(abi.encode(\\\"SAVED_FUNDING_FACTOR_PER_SECOND\\\"));\\n    // @dev key for funding increase factor\\n    bytes32 public constant FUNDING_INCREASE_FACTOR_PER_SECOND = keccak256(abi.encode(\\\"FUNDING_INCREASE_FACTOR_PER_SECOND\\\"));\\n    // @dev key for funding decrease factor\\n    bytes32 public constant FUNDING_DECREASE_FACTOR_PER_SECOND = keccak256(abi.encode(\\\"FUNDING_DECREASE_FACTOR_PER_SECOND\\\"));\\n    // @dev key for min funding factor\\n    bytes32 public constant MIN_FUNDING_FACTOR_PER_SECOND = keccak256(abi.encode(\\\"MIN_FUNDING_FACTOR_PER_SECOND\\\"));\\n    // @dev key for max funding factor\\n    bytes32 public constant MAX_FUNDING_FACTOR_PER_SECOND = keccak256(abi.encode(\\\"MAX_FUNDING_FACTOR_PER_SECOND\\\"));\\n    // @dev key for threshold for stable funding\\n    bytes32 public constant THRESHOLD_FOR_STABLE_FUNDING = keccak256(abi.encode(\\\"THRESHOLD_FOR_STABLE_FUNDING\\\"));\\n    // @dev key for threshold for decrease funding\\n    bytes32 public constant THRESHOLD_FOR_DECREASE_FUNDING = keccak256(abi.encode(\\\"THRESHOLD_FOR_DECREASE_FUNDING\\\"));\\n    // @dev key for funding fee amount per size\\n    bytes32 public constant FUNDING_FEE_AMOUNT_PER_SIZE = keccak256(abi.encode(\\\"FUNDING_FEE_AMOUNT_PER_SIZE\\\"));\\n    // @dev key for claimable funding amount per size\\n    bytes32 public constant CLAIMABLE_FUNDING_AMOUNT_PER_SIZE = keccak256(abi.encode(\\\"CLAIMABLE_FUNDING_AMOUNT_PER_SIZE\\\"));\\n    // @dev key for when funding was last updated at\\n    bytes32 public constant FUNDING_UPDATED_AT = keccak256(abi.encode(\\\"FUNDING_UPDATED_AT\\\"));\\n    // @dev key for claimable funding amount\\n    bytes32 public constant CLAIMABLE_FUNDING_AMOUNT = keccak256(abi.encode(\\\"CLAIMABLE_FUNDING_AMOUNT\\\"));\\n    // @dev key for claimable collateral amount\\n    bytes32 public constant CLAIMABLE_COLLATERAL_AMOUNT = keccak256(abi.encode(\\\"CLAIMABLE_COLLATERAL_AMOUNT\\\"));\\n    // @dev key for claimable collateral factor\\n    bytes32 public constant CLAIMABLE_COLLATERAL_FACTOR = keccak256(abi.encode(\\\"CLAIMABLE_COLLATERAL_FACTOR\\\"));\\n    // @dev key for claimable collateral reduction factor\\n    bytes32 public constant CLAIMABLE_COLLATERAL_REDUCTION_FACTOR = keccak256(abi.encode(\\\"CLAIMABLE_COLLATERAL_REDUCTION_FACTOR\\\"));\\n    // @dev key for claimable collateral time divisor\\n    bytes32 public constant CLAIMABLE_COLLATERAL_TIME_DIVISOR = keccak256(abi.encode(\\\"CLAIMABLE_COLLATERAL_TIME_DIVISOR\\\"));\\n    // @dev key for claimable collateral delay\\n    bytes32 public constant CLAIMABLE_COLLATERAL_DELAY = keccak256(abi.encode(\\\"CLAIMABLE_COLLATERAL_DELAY\\\"));\\n    // @dev key for claimed collateral amount\\n    bytes32 public constant CLAIMED_COLLATERAL_AMOUNT = keccak256(abi.encode(\\\"CLAIMED_COLLATERAL_AMOUNT\\\"));\\n\\n    bytes32 public constant OPTIMAL_USAGE_FACTOR = keccak256(abi.encode(\\\"OPTIMAL_USAGE_FACTOR\\\"));\\n    bytes32 public constant BASE_BORROWING_FACTOR = keccak256(abi.encode(\\\"BASE_BORROWING_FACTOR\\\"));\\n    bytes32 public constant ABOVE_OPTIMAL_USAGE_BORROWING_FACTOR = keccak256(abi.encode(\\\"ABOVE_OPTIMAL_USAGE_BORROWING_FACTOR\\\"));\\n    bytes32 public constant BORROWING_FACTOR = keccak256(abi.encode(\\\"BORROWING_FACTOR\\\"));\\n    bytes32 public constant BORROWING_EXPONENT_FACTOR = keccak256(abi.encode(\\\"BORROWING_EXPONENT_FACTOR\\\"));\\n    bytes32 public constant SKIP_BORROWING_FEE_FOR_SMALLER_SIDE = keccak256(abi.encode(\\\"SKIP_BORROWING_FEE_FOR_SMALLER_SIDE\\\"));\\n    bytes32 public constant CUMULATIVE_BORROWING_FACTOR = keccak256(abi.encode(\\\"CUMULATIVE_BORROWING_FACTOR\\\"));\\n    bytes32 public constant CUMULATIVE_BORROWING_FACTOR_UPDATED_AT = keccak256(abi.encode(\\\"CUMULATIVE_BORROWING_FACTOR_UPDATED_AT\\\"));\\n    bytes32 public constant TOTAL_BORROWING = keccak256(abi.encode(\\\"TOTAL_BORROWING\\\"));\\n\\n    bytes32 public constant USE_OPEN_INTEREST_IN_TOKENS_FOR_BALANCE = keccak256(abi.encode(\\\"USE_OPEN_INTEREST_IN_TOKENS_FOR_BALANCE\\\"));\\n\\n    // @dev key for affiliate reward\\n    bytes32 public constant MIN_AFFILIATE_REWARD_FACTOR = keccak256(abi.encode(\\\"MIN_AFFILIATE_REWARD_FACTOR\\\"));\\n    bytes32 public constant AFFILIATE_REWARD = keccak256(abi.encode(\\\"AFFILIATE_REWARD\\\"));\\n    // @dev key for max allowed subaccount action count\\n    bytes32 public constant MAX_ALLOWED_SUBACCOUNT_ACTION_COUNT = keccak256(abi.encode(\\\"MAX_ALLOWED_SUBACCOUNT_ACTION_COUNT\\\"));\\n    bytes32 public constant SUBACCOUNT_EXPIRES_AT = keccak256(abi.encode(\\\"SUBACCOUNT_EXPIRES_AT\\\"));\\n    // @dev key for subaccount action count\\n    bytes32 public constant SUBACCOUNT_ACTION_COUNT = keccak256(abi.encode(\\\"SUBACCOUNT_ACTION_COUNT\\\"));\\n    // @dev key for subaccount auto top up amount\\n    bytes32 public constant SUBACCOUNT_AUTO_TOP_UP_AMOUNT = keccak256(abi.encode(\\\"SUBACCOUNT_AUTO_TOP_UP_AMOUNT\\\"));\\n    // @dev key for subaccount order action\\n    bytes32 public constant SUBACCOUNT_ORDER_ACTION = keccak256(abi.encode(\\\"SUBACCOUNT_ORDER_ACTION\\\"));\\n    // @dev key for subaccount integration id\\n    bytes32 public constant SUBACCOUNT_INTEGRATION_ID = keccak256(abi.encode(\\\"SUBACCOUNT_INTEGRATION_ID\\\"));\\n    // @dev key for subaccount integration id disabled status\\n    bytes32 public constant SUBACCOUNT_INTEGRATION_DISABLED = keccak256(abi.encode(\\\"SUBACCOUNT_INTEGRATION_DISABLED\\\"));\\n    // @dev key for fee distributor swap order token index\\n    bytes32 public constant FEE_DISTRIBUTOR_SWAP_TOKEN_INDEX = keccak256(abi.encode(\\\"FEE_DISTRIBUTOR_SWAP_TOKEN_INDEX\\\"));\\n    // @dev key for fee distributor swap fee batch\\n    bytes32 public constant FEE_DISTRIBUTOR_SWAP_FEE_BATCH = keccak256(abi.encode(\\\"FEE_DISTRIBUTOR_SWAP_FEE_BATCH\\\"));\\n\\n    bytes32 public constant GLV_MAX_MARKET_COUNT = keccak256(abi.encode(\\\"GLV_MAX_MARKET_COUNT\\\"));\\n    bytes32 public constant GLV_MAX_MARKET_TOKEN_BALANCE_USD = keccak256(abi.encode(\\\"GLV_MAX_MARKET_TOKEN_BALANCE_USD\\\"));\\n    bytes32 public constant GLV_MAX_MARKET_TOKEN_BALANCE_AMOUNT = keccak256(abi.encode(\\\"GLV_MAX_MARKET_TOKEN_BALANCE_AMOUNT\\\"));\\n    bytes32 public constant IS_GLV_MARKET_DISABLED = keccak256(abi.encode(\\\"IS_GLV_MARKET_DISABLED\\\"));\\n    bytes32 public constant GLV_SHIFT_MAX_LOSS_FACTOR = keccak256(abi.encode(\\\"GLV_SHIFT_MAX_LOSS_FACTOR\\\"));\\n    bytes32 public constant GLV_SHIFT_LAST_EXECUTED_AT = keccak256(abi.encode(\\\"GLV_SHIFT_LAST_EXECUTED_AT\\\"));\\n    bytes32 public constant GLV_SHIFT_MIN_INTERVAL = keccak256(abi.encode(\\\"GLV_SHIFT_MIN_INTERVAL\\\"));\\n    bytes32 public constant MIN_GLV_TOKENS_FOR_FIRST_DEPOSIT = keccak256(abi.encode(\\\"MIN_GLV_TOKENS_FOR_FIRST_DEPOSIT\\\"));\\n\\n    // @dev key for disabling automatic parameter updates via ConfigSyncer\\n    bytes32 public constant SYNC_CONFIG_FEATURE_DISABLED = keccak256(abi.encode(\\\"SYNC_CONFIG_FEATURE_DISABLED\\\"));\\n    // @dev key for disabling all parameter updates for a specific market via ConfigSyncer\\n    bytes32 public constant SYNC_CONFIG_MARKET_DISABLED = keccak256(abi.encode(\\\"SYNC_CONFIG_MARKET_DISABLED\\\"));\\n    // @dev key for disabling all updates for a specific parameter via ConfigSyncer\\n    bytes32 public constant SYNC_CONFIG_PARAMETER_DISABLED = keccak256(abi.encode(\\\"SYNC_CONFIG_PARAMETER_DISABLED\\\"));\\n    // @dev key for disabling all updates for a specific market parameter via ConfigSyncer\\n    bytes32 public constant SYNC_CONFIG_MARKET_PARAMETER_DISABLED = keccak256(abi.encode(\\\"SYNC_CONFIG_MARKET_PARAMETER_DISABLED\\\"));\\n    // @dev key for tracking which updateIds have already been applied by ConfigSyncer\\n    bytes32 public constant SYNC_CONFIG_UPDATE_COMPLETED = keccak256(abi.encode(\\\"SYNC_CONFIG_UPDATE_COMPLETED\\\"));\\n    // @dev key for the latest updateId that has been applied by ConfigSyncer\\n    bytes32 public constant SYNC_CONFIG_LATEST_UPDATE_ID = keccak256(abi.encode(\\\"SYNC_CONFIG_LATEST_UPDATE_ID\\\"));\\n\\n    bytes32 public constant CONTRIBUTOR_ACCOUNT_LIST = keccak256(abi.encode(\\\"CONTRIBUTOR_ACCOUNT_LIST\\\"));\\n    bytes32 public constant CONTRIBUTOR_TOKEN_LIST = keccak256(abi.encode(\\\"CONTRIBUTOR_TOKEN_LIST\\\"));\\n    bytes32 public constant CONTRIBUTOR_TOKEN_AMOUNT = keccak256(abi.encode(\\\"CONTRIBUTOR_TOKEN_AMOUNT\\\"));\\n    bytes32 public constant MAX_TOTAL_CONTRIBUTOR_TOKEN_AMOUNT = keccak256(abi.encode(\\\"MAX_TOTAL_CONTRIBUTOR_TOKEN_AMOUNT\\\"));\\n    bytes32 public constant CONTRIBUTOR_FUNDING_ACCOUNT = keccak256(abi.encode(\\\"CONTRIBUTOR_FUNDING_ACCOUNT\\\"));\\n    bytes32 public constant CUSTOM_CONTRIBUTOR_FUNDING_ACCOUNT = keccak256(abi.encode(\\\"CUSTOM_CONTRIBUTOR_FUNDING_ACCOUNT\\\"));\\n    bytes32 public constant CONTRIBUTOR_LAST_PAYMENT_AT = keccak256(abi.encode(\\\"CONTRIBUTOR_LAST_PAYMENT_AT\\\"));\\n    bytes32 public constant MIN_CONTRIBUTOR_PAYMENT_INTERVAL = keccak256(abi.encode(\\\"MIN_CONTRIBUTOR_PAYMENT_INTERVAL\\\"));\\n\\n    // @dev key for the buyback batch amount used when claiming and swapping fees\\n    bytes32 public constant BUYBACK_BATCH_AMOUNT = keccak256(abi.encode(\\\"BUYBACK_BATCH_AMOUNT\\\"));\\n    // @dev key for the buyback available fees\\n    bytes32 public constant BUYBACK_AVAILABLE_FEE_AMOUNT = keccak256(abi.encode(\\\"BUYBACK_AVAILABLE_FEE_AMOUNT\\\"));\\n    // @dev key for the buyback gmx fee factor used in calculating fees by GMX/WNT\\n    bytes32 public constant BUYBACK_GMX_FACTOR = keccak256(abi.encode(\\\"BUYBACK_GMX_FACTOR\\\"));\\n    // @dev key for the FeeHandler max price impact when buying back fees\\n    bytes32 public constant BUYBACK_MAX_PRICE_IMPACT_FACTOR = keccak256(abi.encode(\\\"BUYBACK_MAX_PRICE_IMPACT_FACTOR\\\"));\\n    // @dev key for the maximum price delay in seconds when buying back fees\\n    bytes32 public constant BUYBACK_MAX_PRICE_AGE = keccak256(abi.encode(\\\"BUYBACK_MAX_PRICE_AGE\\\"));\\n    // @dev key for the buyback withdrawable fees\\n    bytes32 public constant WITHDRAWABLE_BUYBACK_TOKEN_AMOUNT = keccak256(abi.encode(\\\"WITHDRAWABLE_BUYBACK_TOKEN_AMOUNT\\\"));\\n\\n    // @dev key for user's multichain balance\\n    bytes32 public constant MULTICHAIN_BALANCE = keccak256(abi.encode(\\\"MULTICHAIN_BALANCE\\\"));\\n    // @dev key for the flag if a multichain provider is enabled\\n    bytes32 public constant IS_MULTICHAIN_PROVIDER_ENABLED = keccak256(abi.encode(\\\"IS_MULTICHAIN_PROVIDER_ENABLED\\\"));\\n    // @dev key for the flag if a multichain endpoint is enabled\\n    bytes32 public constant IS_MULTICHAIN_ENDPOINT_ENABLED = keccak256(abi.encode(\\\"IS_MULTICHAIN_ENDPOINT_ENABLED\\\"));\\n    // @dev key for the flag if the relay fee is excluded for the caller\\n    bytes32 public constant IS_RELAY_FEE_EXCLUDED = keccak256(abi.encode(\\\"IS_RELAY_FEE_EXCLUDED\\\"));\\n    // @dev key for the flag if a src chain is enabled\\n    bytes32 public constant IS_SRC_CHAIN_ID_ENABLED = keccak256(abi.encode(\\\"IS_SRC_CHAIN_ID_ENABLED\\\"));\\n    // @dev key for the last src chain id from which the user last managed his position\\n    bytes32 public constant POSITION_LAST_SRC_CHAIN_ID = keccak256(abi.encode(\\\"POSITION_LAST_SRC_CHAIN_ID\\\"));\\n    // @dev key for the source chain id mapped from the endpoint id\\n    bytes32 public constant EID_TO_SRC_CHAIN_ID = keccak256(abi.encode(\\\"EID_TO_SRC_CHAIN_ID\\\"));\\n\\n    // @dev key for the maximum length for data list array of bytes32\\n    bytes32 public constant MAX_DATA_LENGTH = keccak256(abi.encode(\\\"MAX_DATA_LENGTH\\\"));\\n    // @dev key for the action data\\n    bytes32 public constant GMX_DATA_ACTION = keccak256(abi.encode(\\\"GMX_DATA_ACTION\\\"));\\n    // @dev key for the claimable fund amount for a specific account and token\\n    bytes32 public constant CLAIMABLE_FUNDS_AMOUNT = keccak256(abi.encode(\\\"CLAIMABLE_FUNDS_AMOUNT\\\"));\\n    // @dev key for the total claimable amount for a specific token\\n    bytes32 public constant TOTAL_CLAIMABLE_FUNDS_AMOUNT = keccak256(abi.encode(\\\"TOTAL_CLAIMABLE_FUNDS_AMOUNT\\\"));\\n    // @dev key for the terms for a specific distribution\\n    bytes32 public constant CLAIM_TERMS = keccak256(abi.encode(\\\"CLAIM_TERMS\\\"));\\n    // @dev key for the terms hash for a specific distribution\\n    bytes32 public constant CLAIM_TERMS_BACKREF = keccak256(abi.encode(\\\"CLAIM_TERMS_BACKREF\\\"));\\n\\n    // @dev constant for user initiated cancel reason\\n    string public constant USER_INITIATED_CANCEL = \\\"USER_INITIATED_CANCEL\\\";\\n\\n    // @dev function used to calculate fullKey for a given market parameter\\n    // @param baseKey the base key for the market parameter\\n    // @param data the additional data for the market parameter\\n    function getFullKey(bytes32 baseKey, bytes memory data) internal pure returns (bytes32) {\\n        if (data.length == 0) {\\n            return baseKey;\\n        }\\n\\n        return keccak256(bytes.concat(baseKey, data));\\n    }\\n\\n    // @dev key for the account deposit list\\n    // @param account the account for the list\\n    function accountDepositListKey(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ACCOUNT_DEPOSIT_LIST, account));\\n    }\\n\\n    // @dev key for the account withdrawal list\\n    // @param account the account for the list\\n    function accountWithdrawalListKey(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ACCOUNT_WITHDRAWAL_LIST, account));\\n    }\\n\\n    // @dev key for the account shift list\\n    // @param account the account for the list\\n    function accountShiftListKey(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ACCOUNT_SHIFT_LIST, account));\\n    }\\n\\n    // @dev key for the account glv deposit list\\n    // @param account the account for the list\\n    function accountGlvDepositListKey(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ACCOUNT_GLV_DEPOSIT_LIST, account));\\n    }\\n\\n    // @dev key for the account glv deposit list\\n    // @param account the account for the list\\n    function accountGlvWithdrawalListKey(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ACCOUNT_GLV_WITHDRAWAL_LIST, account));\\n    }\\n\\n    // @dev key for the glv supported market list\\n    // @param glv the glv for the supported market list\\n    function glvSupportedMarketListKey(address glv) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(GLV_SUPPORTED_MARKET_LIST, glv));\\n    }\\n\\n    // @dev key for the account position list\\n    // @param account the account for the list\\n    function accountPositionListKey(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ACCOUNT_POSITION_LIST, account));\\n    }\\n\\n    // @dev key for the account order list\\n    // @param account the account for the list\\n    function accountOrderListKey(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ACCOUNT_ORDER_LIST, account));\\n    }\\n\\n    // @dev key for the subaccount list\\n    // @param account the account for the list\\n    function subaccountListKey(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(SUBACCOUNT_LIST, account));\\n    }\\n\\n    // @dev key for the auto cancel order list\\n    // @param position key the position key for the list\\n    function autoCancelOrderListKey(bytes32 positionKey) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(AUTO_CANCEL_ORDER_LIST, positionKey));\\n    }\\n\\n    // @dev key for the claimable fee amount\\n    // @param market the market for the fee\\n    // @param token the token for the fee\\n    function claimableFeeAmountKey(address market, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(CLAIMABLE_FEE_AMOUNT, market, token));\\n    }\\n\\n    // @dev key for the claimable ui fee amount\\n    // @param market the market for the fee\\n    // @param token the token for the fee\\n    // @param account the account that can claim the ui fee\\n    function claimableUiFeeAmountKey(address market, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(CLAIMABLE_UI_FEE_AMOUNT, market, token));\\n    }\\n\\n    // @dev key for the claimable ui fee amount for account\\n    // @param market the market for the fee\\n    // @param token the token for the fee\\n    // @param account the account that can claim the ui fee\\n    function claimableUiFeeAmountKey(address market, address token, address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(CLAIMABLE_UI_FEE_AMOUNT, market, token, account));\\n    }\\n\\n    // @dev key for deposit gas limit\\n    // @param singleToken whether a single token or pair tokens are being deposited\\n    // @return key for deposit gas limit\\n    function depositGasLimitKey() internal pure returns (bytes32) {\\n        return DEPOSIT_GAS_LIMIT;\\n    }\\n\\n    // @dev key for withdrawal gas limit\\n    // @return key for withdrawal gas limit\\n    function withdrawalGasLimitKey() internal pure returns (bytes32) {\\n        return WITHDRAWAL_GAS_LIMIT;\\n    }\\n\\n    // @dev key for shift gas limit\\n    // @return key for shift gas limit\\n    function shiftGasLimitKey() internal pure returns (bytes32) {\\n        return SHIFT_GAS_LIMIT;\\n    }\\n\\n    function glvDepositGasLimitKey() internal pure returns (bytes32) {\\n        return GLV_DEPOSIT_GAS_LIMIT;\\n    }\\n\\n    function glvWithdrawalGasLimitKey() internal pure returns (bytes32) {\\n        return GLV_WITHDRAWAL_GAS_LIMIT;\\n    }\\n\\n    function glvShiftGasLimitKey() internal pure returns (bytes32) {\\n        return GLV_SHIFT_GAS_LIMIT;\\n    }\\n\\n    function glvPerMarketGasLimitKey() internal pure returns (bytes32) {\\n        return GLV_PER_MARKET_GAS_LIMIT;\\n    }\\n\\n    // @dev key for single swap gas limit\\n    // @return key for single swap gas limit\\n    function singleSwapGasLimitKey() internal pure returns (bytes32) {\\n        return SINGLE_SWAP_GAS_LIMIT;\\n    }\\n\\n    // @dev key for increase order gas limit\\n    // @return key for increase order gas limit\\n    function increaseOrderGasLimitKey() internal pure returns (bytes32) {\\n        return INCREASE_ORDER_GAS_LIMIT;\\n    }\\n\\n    // @dev key for decrease order gas limit\\n    // @return key for decrease order gas limit\\n    function decreaseOrderGasLimitKey() internal pure returns (bytes32) {\\n        return DECREASE_ORDER_GAS_LIMIT;\\n    }\\n\\n    // @dev key for swap order gas limit\\n    // @return key for swap order gas limit\\n    function swapOrderGasLimitKey() internal pure returns (bytes32) {\\n        return SWAP_ORDER_GAS_LIMIT;\\n    }\\n\\n    function swapPathMarketFlagKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SWAP_PATH_MARKET_FLAG,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for whether create glv deposit is disabled\\n    // @param the create deposit module\\n    // @return key for whether create deposit is disabled\\n    function createGlvDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CREATE_GLV_DEPOSIT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether cancel glv deposit is disabled\\n    // @param the cancel deposit module\\n    // @return key for whether cancel deposit is disabled\\n    function cancelGlvDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CANCEL_GLV_DEPOSIT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether execute glv deposit is disabled\\n    // @param the execute deposit module\\n    // @return key for whether execute deposit is disabled\\n    function executeGlvDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EXECUTE_GLV_DEPOSIT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether create glv withdrawal is disabled\\n    // @param the create withdrawal module\\n    // @return key for whether create withdrawal is disabled\\n    function createGlvWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CREATE_GLV_WITHDRAWAL_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether cancel glv withdrawal is disabled\\n    // @param the cancel withdrawal module\\n    // @return key for whether cancel withdrawal is disabled\\n    function cancelGlvWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CANCEL_GLV_WITHDRAWAL_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether execute glv withdrawal is disabled\\n    // @param the execute withdrawal module\\n    // @return key for whether execute withdrawal is disabled\\n    function executeGlvWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EXECUTE_GLV_WITHDRAWAL_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    function createGlvShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CREATE_GLV_SHIFT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    function executeGlvShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EXECUTE_GLV_SHIFT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    function jitFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            JIT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n\\n    // @dev key for whether create deposit is disabled\\n    // @param the create deposit module\\n    // @return key for whether create deposit is disabled\\n    function createDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CREATE_DEPOSIT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether cancel deposit is disabled\\n    // @param the cancel deposit module\\n    // @return key for whether cancel deposit is disabled\\n    function cancelDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CANCEL_DEPOSIT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether execute deposit is disabled\\n    // @param the execute deposit module\\n    // @return key for whether execute deposit is disabled\\n    function executeDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EXECUTE_DEPOSIT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether create withdrawal is disabled\\n    // @param the create withdrawal module\\n    // @return key for whether create withdrawal is disabled\\n    function createWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CREATE_WITHDRAWAL_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether cancel withdrawal is disabled\\n    // @param the cancel withdrawal module\\n    // @return key for whether cancel withdrawal is disabled\\n    function cancelWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CANCEL_WITHDRAWAL_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether execute withdrawal is disabled\\n    // @param the execute withdrawal module\\n    // @return key for whether execute withdrawal is disabled\\n    function executeWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EXECUTE_WITHDRAWAL_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether execute atomic withdrawal is disabled\\n    // @param the execute atomic withdrawal module\\n    // @return key for whether execute atomic withdrawal is disabled\\n    function executeAtomicWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EXECUTE_ATOMIC_WITHDRAWAL_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether create shift is disabled\\n    // @param the create shift module\\n    // @return key for whether create shift is disabled\\n    function createShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CREATE_SHIFT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether cancel shift is disabled\\n    // @param the cancel shift module\\n    // @return key for whether cancel shift is disabled\\n    function cancelShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CANCEL_SHIFT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether execute shift is disabled\\n    // @param the execute shift module\\n    // @return key for whether execute shift is disabled\\n    function executeShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EXECUTE_SHIFT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether create order is disabled\\n    // @param the create order module\\n    // @return key for whether create order is disabled\\n    function createOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CREATE_ORDER_FEATURE_DISABLED,\\n            module,\\n            orderType\\n        ));\\n    }\\n\\n    // @dev key for whether execute order is disabled\\n    // @param the execute order module\\n    // @return key for whether execute order is disabled\\n    function executeOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EXECUTE_ORDER_FEATURE_DISABLED,\\n            module,\\n            orderType\\n        ));\\n    }\\n\\n    // @dev key for whether execute adl is disabled\\n    // @param the execute adl module\\n    // @return key for whether execute adl is disabled\\n    function executeAdlFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EXECUTE_ADL_FEATURE_DISABLED,\\n            module,\\n            orderType\\n        ));\\n    }\\n\\n    // @dev key for whether update order is disabled\\n    // @param the update order module\\n    // @return key for whether update order is disabled\\n    function updateOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            UPDATE_ORDER_FEATURE_DISABLED,\\n            module,\\n            orderType\\n        ));\\n    }\\n\\n    // @dev key for whether cancel order is disabled\\n    // @param the cancel order module\\n    // @return key for whether cancel order is disabled\\n    function cancelOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CANCEL_ORDER_FEATURE_DISABLED,\\n            module,\\n            orderType\\n        ));\\n    }\\n\\n    // @dev key for whether claim funding fees is disabled\\n    // @param the claim funding fees module\\n    function claimFundingFeesFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIM_FUNDING_FEES_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether claim colltareral is disabled\\n    // @param the claim funding fees module\\n    function claimCollateralFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIM_COLLATERAL_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether claim affiliate rewards is disabled\\n    // @param the claim affiliate rewards module\\n    function claimAffiliateRewardsFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIM_AFFILIATE_REWARDS_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether claim ui fees is disabled\\n    // @param the claim ui fees module\\n    function claimUiFeesFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIM_UI_FEES_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether subaccounts are disabled\\n    // @param the subaccount module\\n    function subaccountFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SUBACCOUNT_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether subaccounts are disabled\\n    // @param the gasless module\\n    function gaslessFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            GASLESS_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    function generalClaimFeatureDisabled(uint256 distributionId) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            GENERAL_CLAIM_FEATURE_DISABLED,\\n            distributionId\\n        ));\\n    }\\n\\n    // @dev key for ui fee factor\\n    // @param account the fee receiver account\\n    // @return key for ui fee factor\\n    function uiFeeFactorKey(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            UI_FEE_FACTOR,\\n            account\\n        ));\\n    }\\n\\n    // @dev key for whether an oracle provider is enabled\\n    // @param provider the oracle provider\\n    // @return key for whether an oracle provider is enabled\\n    function isOracleProviderEnabledKey(address provider) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            IS_ORACLE_PROVIDER_ENABLED,\\n            provider\\n        ));\\n    }\\n\\n    // @dev key for whether an oracle provider is allowed to be used for atomic actions\\n    // @param provider the oracle provider\\n    // @return key for whether an oracle provider is allowed to be used for atomic actions\\n    function isAtomicOracleProviderKey(address provider) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            IS_ATOMIC_ORACLE_PROVIDER,\\n            provider\\n        ));\\n    }\\n\\n    // @dev key for oracle timestamp adjustment\\n    // @param provider the oracle provider\\n    // @param token the token\\n    // @return key for oracle timestamp adjustment\\n    function oracleTimestampAdjustmentKey(address provider, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            ORACLE_TIMESTAMP_ADJUSTMENT,\\n            provider,\\n            token\\n        ));\\n    }\\n\\n    function oracleProviderForTokenKey(address oracle, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            ORACLE_PROVIDER_FOR_TOKEN,\\n            oracle,\\n            token\\n        ));\\n    }\\n\\n    function oracleProviderForTokenKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            ORACLE_PROVIDER_FOR_TOKEN,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for oracle provider update time\\n    // @param token the token\\n    // @param provider address\\n    // @return key for oracle provider updated time\\n    function oracleProviderUpdatedAt(address token, address provider) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            ORACLE_PROVIDER_UPDATED_AT,\\n            token,\\n            provider\\n        ));\\n    }\\n\\n    // @dev key for gas to forward for token transfer\\n    // @param the token to check\\n    // @return key for gas to forward for token transfer\\n    function tokenTransferGasLimit(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            TOKEN_TRANSFER_GAS_LIMIT,\\n            token\\n        ));\\n   }\\n\\n   // @dev the default callback contract\\n   // @param account the user's account\\n   // @param market the address of the market\\n   // @param callbackContract the callback contract\\n   function savedCallbackContract(address account, address market) internal pure returns (bytes32) {\\n       return keccak256(abi.encode(\\n           SAVED_CALLBACK_CONTRACT,\\n           account,\\n           market\\n       ));\\n   }\\n\\n   // @dev the min collateral factor key\\n   // @param the market for the min collateral factor\\n   function minCollateralFactorKey(address market) internal pure returns (bytes32) {\\n       return keccak256(abi.encode(\\n           MIN_COLLATERAL_FACTOR,\\n           market\\n       ));\\n   }\\n\\n   // @dev the min collateral factor for open interest multiplier key\\n   // @param the market for the factor\\n   function minCollateralFactorForOpenInterestMultiplierKey(address market, bool isLong) internal pure returns (bytes32) {\\n       return keccak256(abi.encode(\\n           MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER,\\n           market,\\n           isLong\\n       ));\\n   }\\n\\n    // @dev the min collateral factor for open interest multiplier key\\n    // @param the market for the factor\\n    function minCollateralFactorForLiquidationKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MIN_COLLATERAL_FACTOR_FOR_LIQUIDATION,\\n            market\\n        ));\\n    }\\n\\n   // @dev the key for the virtual token id\\n   // @param the token to get the virtual id for\\n   function virtualTokenIdKey(address token) internal pure returns (bytes32) {\\n       return keccak256(abi.encode(\\n           VIRTUAL_TOKEN_ID,\\n           token\\n       ));\\n   }\\n\\n   // @dev the key for the virtual market id\\n   // @param the market to get the virtual id for\\n   function virtualMarketIdKey(address market) internal pure returns (bytes32) {\\n       return keccak256(abi.encode(\\n           VIRTUAL_MARKET_ID,\\n           market\\n       ));\\n   }\\n\\n   function virtualInventoryForPositionsKey(bytes32 virtualTokenId) internal pure returns (bytes32) {\\n       return keccak256(abi.encode(\\n           VIRTUAL_INVENTORY_FOR_POSITIONS,\\n           virtualTokenId\\n       ));\\n   }\\n\\n   function virtualInventoryForPositionsInTokensKey(bytes32 virtualTokenId) internal pure returns (bytes32) {\\n       return keccak256(abi.encode(\\n           VIRTUAL_INVENTORY_FOR_POSITIONS_IN_TOKENS,\\n           virtualTokenId\\n       ));\\n   }\\n\\n   // @dev the key for the virtual inventory for swaps\\n   // @param the virtualMarketId the virtual market id\\n   // @param the token to check the inventory for\\n   function virtualInventoryForSwapsKey(bytes32 virtualMarketId, bool isLongToken) internal pure returns (bytes32) {\\n       return keccak256(abi.encode(\\n           VIRTUAL_INVENTORY_FOR_SWAPS,\\n           virtualMarketId,\\n           isLongToken\\n       ));\\n   }\\n\\n    // @dev key for position impact factor\\n    // @param market the market address to check\\n    // @param isPositive whether the impact is positive or negative\\n    // @return key for position impact factor\\n    function positionImpactFactorKey(address market, bool isPositive) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            POSITION_IMPACT_FACTOR,\\n            market,\\n            isPositive\\n        ));\\n   }\\n\\n    // @dev key for position impact exponent factor\\n    // @param market the market address to check\\n    // @return key for position impact exponent factor\\n    function positionImpactExponentFactorKey(address market, bool isPositive) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            POSITION_IMPACT_EXPONENT_FACTOR,\\n            market,\\n            isPositive\\n        ));\\n    }\\n\\n    // @dev key for the max position impact factor\\n    // @param market the market address to check\\n    // @return key for the max position impact factor\\n    function maxPositionImpactFactorKey(address market, bool isPositive) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_POSITION_IMPACT_FACTOR,\\n            market,\\n            isPositive\\n        ));\\n    }\\n\\n    // @dev key for the max position impact factor for liquidations\\n    // @param market the market address to check\\n    // @return key for the max position impact factor\\n    function maxPositionImpactFactorForLiquidationsKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_POSITION_IMPACT_FACTOR_FOR_LIQUIDATIONS,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for position fee factor\\n    // @param market the market address to check\\n    // @param balanceWasImproved whether the fee is for an action that has improved the balance\\n    // @return key for position fee factor\\n    function positionFeeFactorKey(address market, bool balanceWasImproved) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            POSITION_FEE_FACTOR,\\n            market,\\n            balanceWasImproved\\n        ));\\n    }\\n\\n    // @dev key for pro trader's tier\\n    function proTraderTierKey(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            PRO_TRADER_TIER,\\n            account\\n        ));\\n    }\\n\\n\\n    // @dev key for pro discount factor for specific tier\\n    function proDiscountFactorKey(uint256 proTier) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            PRO_DISCOUNT_FACTOR,\\n            proTier\\n        ));\\n    }\\n\\n    // @dev key for liquidation fee factor\\n    // @param market the market address to check\\n    // @return key for liquidation fee factor\\n    function liquidationFeeFactorKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            LIQUIDATION_FEE_FACTOR,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for swap impact factor\\n    // @param market the market address to check\\n    // @param isPositive whether the impact is positive or negative\\n    // @return key for swap impact factor\\n    function swapImpactFactorKey(address market, bool isPositive) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SWAP_IMPACT_FACTOR,\\n            market,\\n            isPositive\\n        ));\\n    }\\n\\n    // @dev key for swap impact exponent factor\\n    // @param market the market address to check\\n    // @return key for swap impact exponent factor\\n    function swapImpactExponentFactorKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SWAP_IMPACT_EXPONENT_FACTOR,\\n            market\\n        ));\\n    }\\n\\n\\n    // @dev key for swap fee factor\\n    // @param market the market address to check\\n    // @param balanceWasImproved whether the fee is for an action that has improved the balance\\n    // @return key for swap fee factor\\n    function swapFeeFactorKey(address market, bool balanceWasImproved) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SWAP_FEE_FACTOR,\\n            market,\\n            balanceWasImproved\\n        ));\\n    }\\n\\n    // @dev key for atomic swap fee factor\\n    // @param market the market address to check\\n    // @return key for atomic swap fee factor\\n    function atomicSwapFeeFactorKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            ATOMIC_SWAP_FEE_FACTOR,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for atomic withdrawal fee factor\\n    // @param market the market address to check\\n    // @return key for atomic withdrawal fee factor\\n    function atomicWithdrawalFeeFactorKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            ATOMIC_WITHDRAWAL_FEE_FACTOR,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for deposit fee factor\\n    // @param balanceWasImproved whether the fee is for an action that has improved the balance\\n    // @return key for deposit fee factor\\n    function depositFeeFactorKey(address market, bool balanceWasImproved) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            DEPOSIT_FEE_FACTOR,\\n            market,\\n            balanceWasImproved\\n        ));\\n    }\\n\\n    // @dev key for withdrawal fee factor\\n    // @param market the market address to check\\n    // @param balanceWasImproved whether the fee is for an action that has improved the balance\\n    // @return key for withdrawal fee factor\\n    function withdrawalFeeFactorKey(address market, bool balanceWasImproved) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            WITHDRAWAL_FEE_FACTOR,\\n            market,\\n            balanceWasImproved\\n        ));\\n    }\\n\\n    // @dev key for oracle type\\n    // @param token the token to check\\n    // @return key for oracle type\\n    function oracleTypeKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            ORACLE_TYPE,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for open interest\\n    // @param market the market to check\\n    // @param collateralToken the collateralToken to check\\n    // @param isLong whether to check the long or short open interest\\n    // @return key for open interest\\n    function openInterestKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            OPEN_INTEREST,\\n            market,\\n            collateralToken,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for open interest in tokens\\n    // @param market the market to check\\n    // @param collateralToken the collateralToken to check\\n    // @param isLong whether to check the long or short open interest\\n    // @return key for open interest in tokens\\n    function openInterestInTokensKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            OPEN_INTEREST_IN_TOKENS,\\n            market,\\n            collateralToken,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for collateral sum for a market\\n    // @param market the market to check\\n    // @param collateralToken the collateralToken to check\\n    // @param isLong whether to check the long or short open interest\\n    // @return key for collateral sum\\n    function collateralSumKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            COLLATERAL_SUM,\\n            market,\\n            collateralToken,\\n            isLong\\n        ));\\n    }\\n\\n    function maxCollateralSumKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_COLLATERAL_SUM,\\n            market,\\n            collateralToken,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for amount of tokens in a market's pool\\n    // @param market the market to check\\n    // @param token the token to check\\n    // @return key for amount of tokens in a market's pool\\n    function poolAmountKey(address market, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            POOL_AMOUNT,\\n            market,\\n            token\\n        ));\\n    }\\n\\n    // @dev the key for the max amount of pool tokens\\n    // @param market the market for the pool\\n    // @param token the token for the pool\\n    function maxPoolAmountKey(address market, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_POOL_AMOUNT,\\n            market,\\n            token\\n        ));\\n    }\\n\\n    // @dev the key for the max usd of pool tokens for deposits\\n    // @param market the market for the pool\\n    // @param token the token for the pool\\n    function maxPoolUsdForDepositKey(address market, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_POOL_USD_FOR_DEPOSIT,\\n            market,\\n            token\\n        ));\\n    }\\n\\n    // @dev the key for the max open interest\\n    // @param market the market for the pool\\n    // @param isLong whether the key is for the long or short side\\n    function maxOpenInterestKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_OPEN_INTEREST,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for amount of tokens in a market's position impact pool\\n    // @param market the market to check\\n    // @return key for amount of tokens in a market's position impact pool\\n    function positionImpactPoolAmountKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            POSITION_IMPACT_POOL_AMOUNT,\\n            market\\n        ));\\n    }\\n\\n    function lentPositionImpactPoolAmountKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            LENT_POSITION_IMPACT_POOL_AMOUNT,\\n            market\\n        ));\\n    }\\n\\n    function maxLendableImpactFactorKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_LENDABLE_IMPACT_FACTOR,\\n            market\\n        ));\\n    }\\n\\n    function maxLendableImpactFactorForWithdrawalsKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_LENDABLE_IMPACT_FACTOR_FOR_WITHDRAWALS,\\n            market\\n        ));\\n    }\\n\\n    function maxLendableImpactUsdKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_LENDABLE_IMPACT_USD,\\n            market\\n        ));\\n    }\\n\\n    function totalPendingImpactAmountKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            TOTAL_PENDING_IMPACT_AMOUNT,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for min amount of tokens in a market's position impact pool\\n    // @param market the market to check\\n    // @return key for min amount of tokens in a market's position impact pool\\n    function minPositionImpactPoolAmountKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MIN_POSITION_IMPACT_POOL_AMOUNT,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for position impact pool distribution rate\\n    // @param market the market to check\\n    // @return key for position impact pool distribution rate\\n    function positionImpactPoolDistributionRateKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            POSITION_IMPACT_POOL_DISTRIBUTION_RATE,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for position impact pool distributed at\\n    // @param market the market to check\\n    // @return key for position impact pool distributed at\\n    function positionImpactPoolDistributedAtKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            POSITION_IMPACT_POOL_DISTRIBUTED_AT,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for amount of tokens in a market's swap impact pool\\n    // @param market the market to check\\n    // @param token the token to check\\n    // @return key for amount of tokens in a market's swap impact pool\\n    function swapImpactPoolAmountKey(address market, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SWAP_IMPACT_POOL_AMOUNT,\\n            market,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for reserve factor\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for reserve factor\\n    function reserveFactorKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            RESERVE_FACTOR,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for open interest reserve factor\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for open interest reserve factor\\n    function openInterestReserveFactorKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            OPEN_INTEREST_RESERVE_FACTOR,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for max pnl factor\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for max pnl factor\\n    function maxPnlFactorKey(bytes32 pnlFactorType, address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_PNL_FACTOR,\\n            pnlFactorType,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev the key for min PnL factor after ADL\\n    // @param market the market for the pool\\n    // @param isLong whether the key is for the long or short side\\n    function minPnlFactorAfterAdlKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MIN_PNL_FACTOR_AFTER_ADL,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for latest adl time\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for latest adl time\\n    function latestAdlAtKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            LATEST_ADL_AT,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for whether adl is enabled\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for whether adl is enabled\\n    function isAdlEnabledKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            IS_ADL_ENABLED,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for funding factor\\n    // @param market the market to check\\n    // @return key for funding factor\\n    function fundingFactorKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            FUNDING_FACTOR,\\n            market\\n        ));\\n    }\\n\\n    // @dev the key for funding exponent\\n    // @param market the market for the pool\\n    function fundingExponentFactorKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            FUNDING_EXPONENT_FACTOR,\\n            market\\n        ));\\n    }\\n\\n    // @dev the key for saved funding factor\\n    // @param market the market for the pool\\n    function savedFundingFactorPerSecondKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SAVED_FUNDING_FACTOR_PER_SECOND,\\n            market\\n        ));\\n    }\\n\\n    // @dev the key for funding increase factor\\n    // @param market the market for the pool\\n    function fundingIncreaseFactorPerSecondKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            FUNDING_INCREASE_FACTOR_PER_SECOND,\\n            market\\n        ));\\n    }\\n\\n    // @dev the key for funding decrease factor\\n    // @param market the market for the pool\\n    function fundingDecreaseFactorPerSecondKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            FUNDING_DECREASE_FACTOR_PER_SECOND,\\n            market\\n        ));\\n    }\\n\\n    // @dev the key for min funding factor\\n    // @param market the market for the pool\\n    function minFundingFactorPerSecondKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MIN_FUNDING_FACTOR_PER_SECOND,\\n            market\\n        ));\\n    }\\n\\n    // @dev the key for max funding factor\\n    // @param market the market for the pool\\n    function maxFundingFactorPerSecondKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_FUNDING_FACTOR_PER_SECOND,\\n            market\\n        ));\\n    }\\n\\n    // @dev the key for threshold for stable funding\\n    // @param market the market for the pool\\n    function thresholdForStableFundingKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            THRESHOLD_FOR_STABLE_FUNDING,\\n            market\\n        ));\\n    }\\n\\n    // @dev the key for threshold for decreasing funding\\n    // @param market the market for the pool\\n    function thresholdForDecreaseFundingKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            THRESHOLD_FOR_DECREASE_FUNDING,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for funding fee amount per size\\n    // @param market the market to check\\n    // @param collateralToken the collateralToken to get the key for\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for funding fee amount per size\\n    function fundingFeeAmountPerSizeKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            FUNDING_FEE_AMOUNT_PER_SIZE,\\n            market,\\n            collateralToken,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for claimabel funding amount per size\\n    // @param market the market to check\\n    // @param collateralToken the collateralToken to get the key for\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for claimable funding amount per size\\n    function claimableFundingAmountPerSizeKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIMABLE_FUNDING_AMOUNT_PER_SIZE,\\n            market,\\n            collateralToken,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for when funding was last updated\\n    // @param market the market to check\\n    // @return key for when funding was last updated\\n    function fundingUpdatedAtKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            FUNDING_UPDATED_AT,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for claimable funding amount\\n    // @param market the market to check\\n    // @param token the token to check\\n    // @return key for claimable funding amount\\n    function claimableFundingAmountKey(address market, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIMABLE_FUNDING_AMOUNT,\\n            market,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for claimable funding amount by account\\n    // @param market the market to check\\n    // @param token the token to check\\n    // @param account the account to check\\n    // @return key for claimable funding amount\\n    function claimableFundingAmountKey(address market, address token, address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIMABLE_FUNDING_AMOUNT,\\n            market,\\n            token,\\n            account\\n        ));\\n    }\\n\\n    // @dev key for claimable collateral amount\\n    // @param market the market to check\\n    // @param token the token to check\\n    // @param account the account to check\\n    // @param timeKey the time key for the claimable amount\\n    // @return key for claimable funding amount\\n    function claimableCollateralAmountKey(address market, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIMABLE_COLLATERAL_AMOUNT,\\n            market,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for claimable collateral amount for a timeKey for an account\\n    // @param market the market to check\\n    // @param token the token to check\\n    // @param account the account to check\\n    // @param timeKey the time key for the claimable amount\\n    // @return key for claimable funding amount\\n    function claimableCollateralAmountKey(address market, address token, uint256 timeKey, address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIMABLE_COLLATERAL_AMOUNT,\\n            market,\\n            token,\\n            timeKey,\\n            account\\n        ));\\n    }\\n\\n    // @dev key for claimable collateral factor for a timeKey\\n    // @param market the market to check\\n    // @param token the token to check\\n    // @param timeKey the time key for the claimable amount\\n    // @return key for claimable funding amount\\n    function claimableCollateralFactorKey(address market, address token, uint256 timeKey) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIMABLE_COLLATERAL_FACTOR,\\n            market,\\n            token,\\n            timeKey\\n        ));\\n    }\\n\\n    // @dev key for claimable collateral factor for a timeKey for an account\\n    // @param market the market to check\\n    // @param token the token to check\\n    // @param timeKey the time key for the claimable amount\\n    // @param account the account to check\\n    // @return key for claimable funding amount\\n    function claimableCollateralFactorKey(address market, address token, uint256 timeKey, address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIMABLE_COLLATERAL_FACTOR,\\n            market,\\n            token,\\n            timeKey,\\n            account\\n        ));\\n    }\\n\\n    // @dev key for claimable collateral reduction factor for a timeKey for an account\\n    // @param market the market to check\\n    // @param token the token to check\\n    // @param timeKey the time key for the claimable factor\\n    // @param account the account to check\\n    // @return key for claimable funding factor\\n    function claimableCollateralReductionFactorKey(address market, address token, uint256 timeKey, address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIMABLE_COLLATERAL_REDUCTION_FACTOR,\\n            market,\\n            token,\\n            timeKey,\\n            account\\n        ));\\n    }\\n\\n    // @dev key for claimable collateral factor\\n    // @param market the market to check\\n    // @param token the token to check\\n    // @param account the account to check\\n    // @param timeKey the time key for the claimable amount\\n    // @return key for claimable funding amount\\n    function claimedCollateralAmountKey(address market, address token, uint256 timeKey, address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIMED_COLLATERAL_AMOUNT,\\n            market,\\n            token,\\n            timeKey,\\n            account\\n        ));\\n    }\\n\\n    // @dev key for optimal usage factor\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for optimal usage factor\\n    function optimalUsageFactorKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            OPTIMAL_USAGE_FACTOR,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for base borrowing factor\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for base borrowing factor\\n    function baseBorrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            BASE_BORROWING_FACTOR,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for above optimal usage borrowing factor\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for above optimal usage borrowing factor\\n    function aboveOptimalUsageBorrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            ABOVE_OPTIMAL_USAGE_BORROWING_FACTOR,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for borrowing factor\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for borrowing factor\\n    function borrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            BORROWING_FACTOR,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev the key for borrowing exponent\\n    // @param market the market for the pool\\n    // @param isLong whether to get the key for the long or short side\\n    function borrowingExponentFactorKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            BORROWING_EXPONENT_FACTOR,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for cumulative borrowing factor\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for cumulative borrowing factor\\n    function cumulativeBorrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CUMULATIVE_BORROWING_FACTOR,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for cumulative borrowing factor updated at\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for cumulative borrowing factor updated at\\n    function cumulativeBorrowingFactorUpdatedAtKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CUMULATIVE_BORROWING_FACTOR_UPDATED_AT,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for total borrowing amount\\n    // @param market the market to check\\n    // @param isLong whether to get the key for the long or short side\\n    // @return key for total borrowing amount\\n    function totalBorrowingKey(address market, bool isLong) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            TOTAL_BORROWING,\\n            market,\\n            isLong\\n        ));\\n    }\\n\\n    // @dev key for affiliate reward amount\\n    // @param market the market to check\\n    // @param token the token to get the key for\\n    // @param account the account to get the key for\\n    // @return key for affiliate reward amount\\n    function affiliateRewardKey(address market, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            AFFILIATE_REWARD,\\n            market,\\n            token\\n        ));\\n    }\\n\\n    function minAffiliateRewardFactorKey(uint256 referralTierLevel) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MIN_AFFILIATE_REWARD_FACTOR,\\n            referralTierLevel\\n        ));\\n    }\\n\\n    function maxAllowedSubaccountActionCountKey(address account, address subaccount, bytes32 actionType) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_ALLOWED_SUBACCOUNT_ACTION_COUNT,\\n            account,\\n            subaccount,\\n            actionType\\n        ));\\n    }\\n\\n    function subaccountExpiresAtKey(address account, address subaccount, bytes32 actionType) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SUBACCOUNT_EXPIRES_AT,\\n            account,\\n            subaccount,\\n            actionType\\n        ));\\n    }\\n\\n    function subaccountActionCountKey(address account, address subaccount, bytes32 actionType) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SUBACCOUNT_ACTION_COUNT,\\n            account,\\n            subaccount,\\n            actionType\\n        ));\\n    }\\n\\n    function subaccountAutoTopUpAmountKey(address account, address subaccount) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SUBACCOUNT_AUTO_TOP_UP_AMOUNT,\\n            account,\\n            subaccount\\n        ));\\n    }\\n\\n    function subaccountIntegrationIdKey(address account, address subaccount) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SUBACCOUNT_INTEGRATION_ID,\\n            account,\\n            subaccount\\n        ));\\n    }\\n\\n    function subaccountIntegrationDisabledKey(bytes32 integrationId) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SUBACCOUNT_INTEGRATION_DISABLED,\\n            integrationId\\n        ));\\n    }\\n\\n    // @dev key for affiliate reward amount for an account\\n    // @param market the market to check\\n    // @param token the token to get the key for\\n    // @param account the account to get the key for\\n    // @return key for affiliate reward amount\\n    function affiliateRewardKey(address market, address token, address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            AFFILIATE_REWARD,\\n            market,\\n            token,\\n            account\\n        ));\\n    }\\n\\n    // @dev key for is market disabled\\n    // @param market the market to check\\n    // @return key for is market disabled\\n    function isMarketDisabledKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            IS_MARKET_DISABLED,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for min market tokens for first deposit\\n    // @param market the market to check\\n    // @return key for min market tokens for first deposit\\n    function minMarketTokensForFirstDepositKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MIN_MARKET_TOKENS_FOR_FIRST_DEPOSIT,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for price feed address\\n    // @param token the token to get the key for\\n    // @return key for price feed address\\n    function priceFeedKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            PRICE_FEED,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for data stream feed ID\\n    // @param token the token to get the key for\\n    // @return key for data stream feed ID\\n    function dataStreamIdKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            DATA_STREAM_ID,\\n            token\\n        ));\\n    }\\n\\n    function edgeDataStreamIdKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EDGE_DATA_STREAM_ID,\\n            token\\n        ));\\n    }\\n\\n    function edgeDataStreamTokenDecimalsKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EDGE_DATA_STREAM_TOKEN_DECIMALS,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for data stream feed multiplier\\n    // @param token the token to get the key for\\n    // @return key for data stream feed multiplier\\n    function dataStreamMultiplierKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            DATA_STREAM_MULTIPLIER,\\n            token\\n        ));\\n    }\\n\\n    function dataStreamSpreadReductionFactorKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            DATA_STREAM_SPREAD_REDUCTION_FACTOR,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for price feed multiplier\\n    // @param token the token to get the key for\\n    // @return key for price feed multiplier\\n    function priceFeedMultiplierKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            PRICE_FEED_MULTIPLIER,\\n            token\\n        ));\\n    }\\n\\n    function priceFeedHeartbeatDurationKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            PRICE_FEED_HEARTBEAT_DURATION,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for stable price value\\n    // @param token the token to get the key for\\n    // @return key for stable price value\\n    function stablePriceKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            STABLE_PRICE,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for fee distributor swap token index\\n    // @param orderKey the swap order key\\n    // @return key for fee distributor swap token index\\n    function feeDistributorSwapTokenIndexKey(bytes32 orderKey) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            FEE_DISTRIBUTOR_SWAP_TOKEN_INDEX,\\n            orderKey\\n        ));\\n    }\\n\\n    // @dev key for fee distributor swap fee batch key\\n    // @param orderKey the swap order key\\n    // @return key for fee distributor swap fee batch key\\n    function feeDistributorSwapFeeBatchKey(bytes32 orderKey) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            FEE_DISTRIBUTOR_SWAP_FEE_BATCH,\\n            orderKey\\n        ));\\n    }\\n\\n    // @dev key for max market token balance usd\\n    // it is used to limit amount of funds deposited into each market\\n    function glvMaxMarketTokenBalanceUsdKey(address glv, address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(GLV_MAX_MARKET_TOKEN_BALANCE_USD, glv, market));\\n    }\\n\\n    // @dev key for max market token balance amount\\n    // it is used to limit amount of funds deposited into each market\\n    function glvMaxMarketTokenBalanceAmountKey(address glv, address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(GLV_MAX_MARKET_TOKEN_BALANCE_AMOUNT, glv, market));\\n    }\\n\\n    // @dev key for is glv market disabled\\n    function isGlvMarketDisabledKey(address glv, address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            IS_GLV_MARKET_DISABLED,\\n            glv,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for max allowed price impact for glv shifts\\n    // if effective price impact exceeds max price impact then glv shift fails\\n    function glvShiftMaxLossFactorKey(address glv) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            GLV_SHIFT_MAX_LOSS_FACTOR,\\n            glv\\n        ));\\n    }\\n\\n    // @dev key for time when glv shift was executed last\\n    // used to validate glv shifts are not executed too frequently\\n    function glvShiftLastExecutedAtKey(address glv) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            GLV_SHIFT_LAST_EXECUTED_AT,\\n            glv\\n        ));\\n    }\\n\\n    // @dev key for min time interval between glv shifts in seconds\\n    function glvShiftMinIntervalKey(address glv) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            GLV_SHIFT_MIN_INTERVAL,\\n            glv\\n        ));\\n    }\\n\\n    function minGlvTokensForFirstGlvDepositKey(address glv) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MIN_GLV_TOKENS_FOR_FIRST_DEPOSIT,\\n            glv\\n        ));\\n    }\\n\\n    // @dev key for whether the sync config feature is disabled\\n    // @param module the sync config module\\n    // @return key for sync config feature disabled\\n    function syncConfigFeatureDisabledKey(address module) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SYNC_CONFIG_FEATURE_DISABLED,\\n            module\\n        ));\\n    }\\n\\n    // @dev key for whether sync config updates are disabled for a market\\n    // @param market the market to check\\n    // @return key for sync config market disabled\\n    function syncConfigMarketDisabledKey(address market) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SYNC_CONFIG_MARKET_DISABLED,\\n            market\\n        ));\\n    }\\n\\n    // @dev key for whether sync config updates are disabled for a parameter\\n    // @param parameter the parameter to check\\n    // @return key for sync config parameter disabled\\n    function syncConfigParameterDisabledKey(string memory parameter) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SYNC_CONFIG_PARAMETER_DISABLED,\\n            parameter\\n        ));\\n    }\\n\\n    // @dev key for whether sync config updates are disabled for a market parameter\\n    // @param market the market to check\\n    // @param parameter the parameter to check\\n    // @return key for sync config market parameter disabled\\n    function syncConfigMarketParameterDisabledKey(address market, string memory parameter) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SYNC_CONFIG_MARKET_PARAMETER_DISABLED,\\n            market,\\n            parameter\\n        ));\\n    }\\n\\n    // @dev key for whether a sync config update is completed\\n    // @param updateId the update id to check\\n    // @return key for sync config market update completed\\n    function syncConfigUpdateCompletedKey(uint256 updateId) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            SYNC_CONFIG_UPDATE_COMPLETED,\\n            updateId\\n        ));\\n    }\\n\\n    // @dev key for the latest sync config update that was completed\\n    // @return key for sync config latest update id\\n    function syncConfigLatestUpdateIdKey() internal pure returns (bytes32) {\\n        return SYNC_CONFIG_LATEST_UPDATE_ID;\\n    }\\n\\n    // @dev key for the contributor token amount\\n    // @param account the contributor account\\n    // @param token the contributor token\\n    // @return key for the contributor token amount\\n    function contributorTokenAmountKey(address account, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CONTRIBUTOR_TOKEN_AMOUNT,\\n            account,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for the max total contributor token amount\\n    // @param token the contributor token\\n    // @return key for the max contributor token amount\\n    function maxTotalContributorTokenAmountKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MAX_TOTAL_CONTRIBUTOR_TOKEN_AMOUNT,\\n            token\\n        ));\\n    }\\n\\n    function contributorFundingAccountKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CONTRIBUTOR_FUNDING_ACCOUNT,\\n            token\\n        ));\\n    }\\n\\n    function customContributorFundingAccountKey(address account, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CUSTOM_CONTRIBUTOR_FUNDING_ACCOUNT,\\n            account,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for the buyback batch amount\\n    // @param token the token for which to retrieve batch amount (GMX or WNT)\\n    // @return key for buyback batch amount for a given token\\n    function buybackBatchAmountKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            BUYBACK_BATCH_AMOUNT,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for the buyback available fee amount\\n    // @param feeToken the token in which the fees are denominated\\n    // @param swapToken the token for which fees are accumulated (GMX or WNT)\\n    // @return key for buyback available fee amount for a given token and feeToken\\n    function buybackAvailableFeeAmountKey(address feeToken, address swapToken) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            BUYBACK_AVAILABLE_FEE_AMOUNT,\\n            feeToken,\\n            swapToken\\n        ));\\n    }\\n\\n    // @dev key for the buyback withdrawable fee amount\\n    // @param buybackToken the token that was bought back\\n    // @return key for the buyback withdrawable fee amount\\n    function withdrawableBuybackTokenAmountKey(address buybackToken) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            WITHDRAWABLE_BUYBACK_TOKEN_AMOUNT,\\n            buybackToken\\n        ));\\n    }\\n\\n    // @dev key for the buyback gmx fee factor\\n    // @param version the version for which to retrieve the fee numerator\\n    // @return key for buyback gmx fee factor for a given version\\n    function buybackGmxFactorKey(uint256 version) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            BUYBACK_GMX_FACTOR,\\n            version\\n        ));\\n    }\\n\\n    // @dev key for the buyback max price impact factor\\n    // @param token the token for which to retrieve the max price impact factor key\\n    // @return key for buyback max price impact factor for a given token\\n    function buybackMaxPriceImpactFactorKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            BUYBACK_MAX_PRICE_IMPACT_FACTOR,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for whether a multichain provider is enabled\\n    // @param provider the multichain provider\\n    // @return key for whether a multichain provider is enabled\\n    function isMultichainProviderEnabledKey(address provider) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            IS_MULTICHAIN_PROVIDER_ENABLED,\\n            provider\\n        ));\\n    }\\n\\n    // @dev key for whether a multichain endpoint is enabled\\n    // @param endpoint the multichain endpoint\\n    // @return key for whether a multichain endpoint is enabled\\n    function isMultichainEndpointEnabledKey(address endpoint) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            IS_MULTICHAIN_ENDPOINT_ENABLED,\\n            endpoint\\n        ));\\n    }\\n\\n    // @dev key for whether a relay fee is excluded for the caller\\n    // @param sender the address of the sender\\n    // @return key for whether a relay fee is excluded\\n    function isRelayFeeExcludedKey(address sender) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            IS_RELAY_FEE_EXCLUDED,\\n            sender\\n        ));\\n    }\\n\\n    // @dev key for whether a multichain endpoint is enabled\\n    // @param endpoint the multichain endpoint\\n    // @return key for whether a multichain endpoint is enabled\\n    function isSrcChainIdEnabledKey(uint256 srcChainId) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            IS_SRC_CHAIN_ID_ENABLED,\\n            srcChainId\\n        ));\\n    }\\n\\n    // @dev key for the last src chain id from which the user last managed his position\\n    // @param positionKey the position key for which to retrieve the last src chain id\\n    // @return key for the last src chain id from which the user last managed his position\\n    function positionLastSrcChainId(bytes32 positionKey) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            POSITION_LAST_SRC_CHAIN_ID,\\n            positionKey\\n        ));\\n    }\\n\\n    // @dev key for the source chain id mapped from the endpoint id\\n    // @param eid the endpoint id of the source chain\\n    // @return key for the srcChainId\\n    function eidToSrcChainId(uint32 eid) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            EID_TO_SRC_CHAIN_ID,\\n            eid\\n        ));\\n    }\\n\\n    // @dev key for user's multichain balance\\n    // @param account the account for which to retrieve the user balance key\\n    // @param token the token for which to retrieve the user balance key\\n    // @return key for multichain balance for a given user and token\\n    function multichainBalanceKey(address account, address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            MULTICHAIN_BALANCE,\\n            account,\\n            token\\n        ));\\n    }\\n\\n    // @dev key for the claimable fund amount for a specific account and token\\n    // @param account the account to claim funds for\\n    // @param token the token to claim\\n    // @param distributionId the distribution id to claim funds for\\n    // @return key for claimable fund amount\\n    function claimableFundsAmountKey(address account, address token, uint256 distributionId) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIMABLE_FUNDS_AMOUNT,\\n            account,\\n            token,\\n            distributionId\\n        ));\\n    }\\n\\n    // @dev key for the total claimable amount for a specific token\\n    // @param token the token for which to retrieve the total claimable amount\\n    // @return key for total claimable amount\\n    function totalClaimableFundsAmountKey(address token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            TOTAL_CLAIMABLE_FUNDS_AMOUNT,\\n            token\\n        ));\\n    }\\n\\n    function claimTermsKey(uint256 distributionId) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIM_TERMS,\\n            distributionId\\n        ));\\n    }\\n\\n    function claimTermsBackrefKey(bytes32 termsHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CLAIM_TERMS_BACKREF,\\n            termsHash\\n        ));\\n    }\\n}\\n\",\"keccak256\":\"0x32313a19b7408d1b35e25c8fade5c08263bd4aea6a502d96860ba7abf84b162e\",\"license\":\"BUSL-1.1\"},\"contracts/error/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Errors {\\n    // AdlHandler errors\\n    error AdlNotRequired(int256 pnlToPoolFactor, uint256 maxPnlFactorForAdl);\\n    error InvalidAdl(int256 nextPnlToPoolFactor, int256 pnlToPoolFactor);\\n    error PnlOvercorrected(int256 nextPnlToPoolFactor, uint256 minPnlFactorForAdl);\\n\\n    // AdlUtils errors\\n    error InvalidSizeDeltaForAdl(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\\n    error AdlNotEnabled();\\n\\n    // AutoCancelUtils errors\\n    error MaxAutoCancelOrdersExceeded(uint256 count, uint256 maxAutoCancelOrders);\\n\\n    // Bank errors\\n    error SelfTransferNotSupported(address receiver);\\n    error InvalidNativeTokenSender(address msgSender);\\n\\n    // BaseHandler errors\\n    error RequestNotYetCancellable(uint256 requestAge, uint256 requestExpirationAge, string requestType);\\n\\n    // CallbackUtils errors\\n    error MaxCallbackGasLimitExceeded(uint256 callbackGasLimit, uint256 maxCallbackGasLimit);\\n    error InsufficientGasLeftForCallback(uint256 gasToBeForwarded, uint256 callbackGasLimit);\\n\\n    // Config errors\\n    error InvalidBaseKey(bytes32 baseKey);\\n    error ConfigValueExceedsAllowedRange(bytes32 baseKey, uint256 value);\\n    error InvalidClaimableFactor(uint256 value);\\n    error InvalidClaimableReductionFactor(uint256 value);\\n    error OracleProviderAlreadyExistsForToken(address oracle, address token);\\n    error OracleProviderMinChangeDelayNotYetPassed(address token, address provider);\\n    error PriceFeedAlreadyExistsForToken(address token);\\n    error DataStreamIdAlreadyExistsForToken(address token);\\n    error EdgeDataStreamIdAlreadyExistsForToken(address token);\\n    error MaxFundingFactorPerSecondLimitExceeded(uint256 maxFundingFactorPerSecond, uint256 limit);\\n    error InvalidPositionImpactPoolDistributionRate(uint256 distributionAmount, uint256 positionImpactPoolAmount);\\n    error MaxDataListLengthExceeded(uint256 dataLength, uint256 maxDataLength);\\n    error EmptyToken();\\n\\n    // ContributorHandler errors\\n    error InvalidSetContributorPaymentInput(uint256 tokensLength, uint256 amountsLength);\\n    error InvalidContributorToken(address token);\\n    error MaxTotalContributorTokenAmountExceeded(address token, uint256 totalAmount, uint256 maxTotalAmount);\\n    error MinContributorPaymentIntervalNotYetPassed(uint256 minPaymentInterval);\\n    error MinContributorPaymentIntervalBelowAllowedRange(uint256 interval);\\n    error InvalidSetMaxTotalContributorTokenAmountInput(uint256 tokensLength, uint256 amountsLength);\\n\\n    // Timelock errors\\n    error ActionAlreadySignalled();\\n    error ActionNotSignalled();\\n    error SignalTimeNotYetPassed(uint256 signalTime);\\n    error InvalidTimelockDelay(uint256 timelockDelay);\\n    error MaxTimelockDelayExceeded(uint256 timelockDelay);\\n    error InvalidFeeReceiver(address receiver);\\n    error InvalidOracleSigner(address signer);\\n    error InvalidHoldingAddress(address account);\\n    error EmptyPositionImpactWithdrawalAmount();\\n    error OraclePriceOutdated();\\n    error EmptyTarget();\\n    error EmptyFundingAccount();\\n    error EmptyReduceLentAmount();\\n    error ReductionExceedsLentAmount(uint256 lentAmount, uint256 totalReductionAmount);\\n\\n    // GlvDepositStoreUtils errors\\n    error GlvDepositNotFound(bytes32 key);\\n    // GlvShiftStoreUtils errors\\n    error GlvShiftNotFound(bytes32 key);\\n    // GlvWithdrawalStoreUtils errors\\n    error GlvWithdrawalNotFound(bytes32 key);\\n    // GlvDepositUtils errors\\n    error EmptyGlvDepositAmounts();\\n    error EmptyGlvMarketAmount();\\n    error EmptyGlvDeposit();\\n    error InvalidMinGlvTokensForFirstGlvDeposit(uint256 minGlvTokens, uint256 expectedMinGlvTokens);\\n    error InvalidReceiverForFirstGlvDeposit(address receiver, address expectedReceiver);\\n    // GlvWithdrawalUtils errors\\n    error EmptyGlvWithdrawal();\\n    error EmptyGlvWithdrawalAmount();\\n    // GlvUtils errors\\n    error EmptyGlv(address glv);\\n    error EmptyGlvTokenSupply();\\n    error GlvNegativeMarketPoolValue(address glv, address market);\\n    error GlvUnsupportedMarket(address glv, address market);\\n    error GlvDisabledMarket(address glv, address market);\\n    error GlvEnabledMarket(address glv, address market);\\n    error GlvNonZeroMarketBalance(address glv, address market);\\n    error GlvMaxMarketCountExceeded(address glv, uint256 glvMaxMarketCount);\\n    error GlvMaxMarketTokenBalanceUsdExceeded(address glv, address market, uint256 maxMarketTokenBalanceUsd, uint256 marketTokenBalanceUsd);\\n    error GlvMaxMarketTokenBalanceAmountExceeded(address glv, address market, uint256 maxMarketTokenBalanceAmount, uint256 marketTokenBalanceAmount);\\n    error GlvInsufficientMarketTokenBalance(address glv, address market, uint256 marketTokenBalance, uint256 marketTokenAmount);\\n    error GlvMarketAlreadyExists(address glv, address market);\\n    error GlvInvalidLongToken(address glv, address provided, address expected);\\n    error GlvInvalidShortToken(address glv, address provided, address expected);\\n    // GlvShiftUtils\\n    error GlvShiftMaxLossExceeded(uint256 effectivePriceImpactFactor, uint256 glvMaxShiftPriceImpactFactor);\\n    error GlvShiftIntervalNotYetPassed(uint256 currentTimestamp, uint256 lastGlvShiftExecutedAt, uint256 glvShiftMinInterval);\\n    // GlvFactory\\n    error GlvAlreadyExists(bytes32 salt, address glv);\\n    error GlvSymbolTooLong();\\n    error GlvNameTooLong();\\n    // GlvStoreUtils\\n    error GlvNotFound(address key);\\n    // Jit\\n    error JitInvalidToMarket(address market, address expectedMarket);\\n    error JitEmptyShiftParams();\\n    error JitUnsupportedOrderType(uint256 orderType);\\n\\n    // DepositStoreUtils errors\\n    error DepositNotFound(bytes32 key);\\n\\n    // DepositUtils errors\\n    error EmptyDeposit();\\n    error EmptyDepositAmounts();\\n\\n    // ExecuteDepositUtils errors\\n    error MinMarketTokens(uint256 received, uint256 expected);\\n    error EmptyDepositAmountsAfterSwap();\\n    error InvalidPoolValueForDeposit(int256 poolValue);\\n    error InvalidSwapOutputToken(address outputToken, address expectedOutputToken);\\n    error InvalidReceiverForFirstDeposit(address receiver, address expectedReceiver);\\n    error InvalidMinMarketTokensForFirstDeposit(uint256 minMarketTokens, uint256 expectedMinMarketTokens);\\n\\n    // ExternalHandler errors\\n    error ExternalCallFailed(bytes data);\\n    error InvalidExternalCallInput(uint256 targetsLength, uint256 dataListLength);\\n    error InvalidExternalReceiversInput(uint256 refundTokensLength, uint256 refundReceiversLength);\\n    error InvalidExternalCallTarget(address target);\\n\\n    // FeeBatchStoreUtils errors\\n    error FeeBatchNotFound(bytes32 key);\\n\\n    // FeeDistributor errors\\n    error InvalidFeeBatchTokenIndex(uint256 tokenIndex, uint256 feeBatchTokensLength);\\n    error InvalidAmountInForFeeBatch(uint256 amountIn, uint256 remainingAmount);\\n    error InvalidSwapPathForV1(address[] path, address bridgingToken);\\n\\n    // GlpMigrator errors\\n    error InvalidGlpAmount(uint256 totalGlpAmountToRedeem, uint256 totalGlpAmount);\\n    error InvalidExecutionFeeForMigration(uint256 totalExecutionFee, uint256 msgValue);\\n\\n    // GlvHandler errors\\n    error InvalidGlvDepositInitialLongToken(address initialLongToken);\\n    error InvalidGlvDepositInitialShortToken(address initialShortToken);\\n    error InvalidGlvDepositSwapPath(uint256 longTokenSwapPathLength, uint256 shortTokenSwapPathLength);\\n    error MinGlvTokens(uint256 received, uint256 expected);\\n\\n    // OrderHandler errors\\n    error OrderNotUpdatable(uint256 orderType);\\n    error InvalidKeeperForFrozenOrder(address keeper);\\n\\n    // FeatureUtils errors\\n    error DisabledFeature(bytes32 key);\\n\\n    // FeeHandler errors\\n    error InvalidBuybackToken(address buybackToken);\\n    error InvalidVersion(uint256 version);\\n    error InsufficientBuybackOutputAmount(address feeToken, address buybackToken, uint256 outputAmount, uint256 minOutputAmount);\\n    error BuybackAndFeeTokenAreEqual(address feeToken, address buybackToken);\\n    error AvailableFeeAmountIsZero(address feeToken, address buybackToken, uint256 availableFeeAmount);\\n    error MaxBuybackPriceAgeExceeded(uint256 priceTimestamp, uint256 buybackMaxPriceAge, uint256 currentTimestamp);\\n    error EmptyClaimFeesMarket();\\n\\n    // GasUtils errors\\n    error InsufficientExecutionFee(uint256 minExecutionFee, uint256 executionFee);\\n    error InsufficientWntAmountForExecutionFee(uint256 wntAmount, uint256 executionFee);\\n    error InsufficientNativeTokenAmount(uint256 msgValue, uint256 expectedNativeValue);\\n    error InsufficientExecutionGasForErrorHandling(uint256 startingGas, uint256 minHandleErrorGas);\\n    error InsufficientExecutionGas(uint256 startingGas, uint256 estimatedGasLimit, uint256 minAdditionalGasForExecution);\\n    error InsufficientHandleExecutionErrorGas(uint256 gas, uint256 minHandleExecutionErrorGas);\\n    error InsufficientGasForCancellation(uint256 gas, uint256 minHandleExecutionErrorGas);\\n    error InsufficientGasForAutoCancellation(uint256 gas, uint256 minHandleExecutionErrorGas);\\n    error InsufficientGasLeft(uint256 gas, uint256 estimatedGasLimit);\\n    error InvalidExecutionFee(uint256 executionFee, uint256 minExecutionFee, uint256 maxExecutionFee);\\n    error EmptyRelayFeeAddress();\\n\\n    // MarketFactory errors\\n    error MarketAlreadyExists(bytes32 salt, address existingMarketAddress);\\n\\n    // MarketStoreUtils errors\\n    error MarketNotFound(address key);\\n\\n    // MarketUtils errors\\n    error EmptyMarket();\\n    error DisabledMarket(address market);\\n    error MaxSwapPathLengthExceeded(uint256 swapPathLengh, uint256 maxSwapPathLength);\\n    error InsufficientPoolAmount(uint256 poolAmount, uint256 amount);\\n    error InsufficientReserve(uint256 reservedUsd, uint256 maxReservedUsd);\\n    error InsufficientReserveForOpenInterest(uint256 reservedUsd, uint256 maxReservedUsd);\\n    error UnableToGetOppositeToken(address inputToken, address market);\\n    error UnexpectedTokenForVirtualInventory(address token, address market);\\n    error EmptyMarketTokenSupply();\\n    error InvalidSwapMarket(address market);\\n    error UnableToGetCachedTokenPrice(address token, address market);\\n    error CollateralAlreadyClaimed(uint256 adjustedClaimableAmount, uint256 claimedAmount);\\n    error OpenInterestCannotBeUpdatedForSwapOnlyMarket(address market);\\n    error MaxOpenInterestExceeded(uint256 openInterest, uint256 maxOpenInterest);\\n    error MaxPoolAmountExceeded(uint256 poolAmount, uint256 maxPoolAmount);\\n    error MaxCollateralSumExceeded(uint256 collateralSum, uint256 maxCollateralSum);\\n    error MaxPoolUsdForDepositExceeded(uint256 poolUsd, uint256 maxPoolUsdForDeposit);\\n    error UnexpectedBorrowingFactor(uint256 positionBorrowingFactor, uint256 cumulativeBorrowingFactor);\\n    error UnableToGetBorrowingFactorEmptyPoolUsd();\\n    error UnableToGetFundingFactorEmptyOpenInterest();\\n    error InvalidPositionMarket(address market);\\n    error InvalidCollateralTokenForMarket(address market, address token);\\n    error PnlFactorExceededForLongs(int256 pnlToPoolFactor, uint256 maxPnlFactor);\\n    error PnlFactorExceededForShorts(int256 pnlToPoolFactor, uint256 maxPnlFactor);\\n    error InvalidUiFeeFactor(uint256 uiFeeFactor, uint256 maxUiFeeFactor);\\n    error EmptyAddressInMarketTokenBalanceValidation(address market, address token);\\n    error InvalidMarketTokenBalance(address market, address token, uint256 balance, uint256 expectedMinBalance);\\n    error InvalidMarketTokenBalanceForCollateralAmount(address market, address token, uint256 balance, uint256 collateralAmount);\\n    error InvalidMarketTokenBalanceForClaimableFunding(address market, address token, uint256 balance, uint256 claimableFundingFeeAmount);\\n    error UnexpectedPoolValue(int256 poolValue);\\n\\n    // MarketPositionImpactUtils errors\\n    error InsufficientImpactPoolValueForWithdrawal(uint256 withdrawalAmount, uint256 poolValue, int256 totalPendingImpactAmount);\\n\\n    // Oracle errors\\n    error SequencerDown();\\n    error SequencerGraceDurationNotYetPassed(uint256 timeSinceUp, uint256 sequencerGraceDuration);\\n    error EmptyValidatedPrices(); // not used, kept for compatibility\\n    error InvalidOracleProvider(address provider);\\n    error InvalidOracleProviderForToken(address provider, address expectedProvider);\\n    error GmEmptySigner(uint256 signerIndex);\\n    error InvalidOracleSetPricesProvidersParam(uint256 tokensLength, uint256 providersLength);\\n    error InvalidOracleSetPricesDataParam(uint256 tokensLength, uint256 dataLength);\\n    error GmInvalidBlockNumber(uint256 minOracleBlockNumber, uint256 currentBlockNumber);\\n    error GmInvalidMinMaxBlockNumber(uint256 minOracleBlockNumber, uint256 maxOracleBlockNumber);\\n    error EmptyDataStreamFeedId(address token);\\n    error InvalidDataStreamFeedId(address token, bytes32 feedId, bytes32 expectedFeedId);\\n    error InvalidDataStreamBidAsk(address token, int192 bid, int192 ask);\\n    error InvalidDataStreamPrices(address token, int192 bid, int192 ask);\\n    error MaxPriceAgeExceeded(uint256 oracleTimestamp, uint256 currentTimestamp);\\n    error MaxOracleTimestampRangeExceeded(uint256 range, uint256 maxRange);\\n    error GmMinOracleSigners(uint256 oracleSigners, uint256 minOracleSigners);\\n    error GmMaxOracleSigners(uint256 oracleSigners, uint256 maxOracleSigners);\\n    error BlockNumbersNotSorted(uint256 minOracleBlockNumber, uint256 prevMinOracleBlockNumber);\\n    error GmMinPricesNotSorted(address token, uint256 price, uint256 prevPrice);\\n    error GmMaxPricesNotSorted(address token, uint256 price, uint256 prevPrice);\\n    error EmptyChainlinkPriceFeedMultiplier(address token);\\n    error EmptyDataStreamMultiplier(address token);\\n    error InvalidDataStreamSpreadReductionFactor(address token, uint256 spreadReductionFactor);\\n    error InvalidFeedPrice(address token, int256 price);\\n    error ChainlinkPriceFeedNotUpdated(address token, uint256 timestamp, uint256 heartbeatDuration);\\n    error GmMaxSignerIndex(uint256 signerIndex, uint256 maxSignerIndex);\\n    error InvalidGmOraclePrice(address token);\\n    error InvalidGmSignerMinMaxPrice(uint256 minPrice, uint256 maxPrice);\\n    error InvalidGmMedianMinMaxPrice(uint256 minPrice, uint256 maxPrice);\\n    error NonEmptyTokensWithPrices(uint256 tokensWithPricesLength);\\n    error InvalidMinMaxForPrice(address token, uint256 min, uint256 max);\\n    error EmptyChainlinkPriceFeed(address token);\\n    error PriceAlreadySet(address token, uint256 minPrice, uint256 maxPrice);\\n    error MaxRefPriceDeviationExceeded(\\n        address token,\\n        uint256 price,\\n        uint256 refPrice,\\n        uint256 maxRefPriceDeviationFactor\\n    );\\n    error InvalidBlockRangeSet(uint256 largestMinBlockNumber, uint256 smallestMaxBlockNumber);\\n    error NonAtomicOracleProvider(address provider);\\n\\n    // OracleModule errors\\n    error InvalidPrimaryPricesForSimulation(uint256 primaryTokensLength, uint256 primaryPricesLength);\\n    error EndOfOracleSimulation();\\n\\n    // OracleUtils errors\\n    error InvalidGmSignature(address recoveredSigner, address expectedSigner);\\n\\n    error EmptyPrimaryPrice(address token);\\n\\n    error OracleTimestampsAreSmallerThanRequired(uint256 minOracleTimestamp, uint256 expectedTimestamp);\\n    error OracleTimestampsAreLargerThanRequestExpirationTime(uint256 maxOracleTimestamp, uint256 requestTimestamp, uint256 requestExpirationTime);\\n\\n    // BaseOrderUtils errors\\n    error EmptyOrder();\\n    error UnsupportedOrderType(uint256 orderType);\\n    error UnsupportedOrderTypeForAutoCancellation(uint256 orderType);\\n    error InvalidOrderPrices(\\n        uint256 primaryPriceMin,\\n        uint256 primaryPriceMax,\\n        uint256 triggerPrice,\\n        uint256 orderType\\n    );\\n    error EmptySizeDeltaInTokens();\\n    error PriceImpactLargerThanOrderSize(int256 priceImpactUsd, uint256 sizeDeltaUsd);\\n    error NegativeExecutionPrice(int256 executionPrice, uint256 price, uint256 positionSizeInUsd, int256 priceImpactUsd, uint256 sizeDeltaUsd);\\n    error OrderNotFulfillableAtAcceptablePrice(uint256 price, uint256 acceptablePrice);\\n    error OrderValidFromTimeNotReached(uint256 validFromTime, uint256 currentTimestamp);\\n\\n    // IncreaseOrderUtils errors\\n    error UnexpectedPositionState();\\n\\n    // OrderUtils errors\\n    error OrderTypeCannotBeCreated(uint256 orderType);\\n    error OrderAlreadyFrozen();\\n    error MaxTotalCallbackGasLimitForAutoCancelOrdersExceeded(uint256 totalCallbackGasLimit, uint256 maxTotalCallbackGasLimit);\\n    error InvalidReceiver(address receiver);\\n    error UnexpectedValidFromTime(uint256 orderType);\\n\\n    // OrderStoreUtils errors\\n    error OrderNotFound(bytes32 key);\\n\\n    // SwapOrderUtils errors\\n    error UnexpectedMarket();\\n\\n    // DecreasePositionCollateralUtils errors\\n    error InsufficientFundsToPayForCosts(uint256 remainingCostUsd, string step);\\n    error InvalidOutputToken(address tokenOut, address expectedTokenOut);\\n\\n    // DecreasePositionUtils errors\\n    error InvalidDecreaseOrderSize(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\\n    error UnableToWithdrawCollateral(int256 estimatedRemainingCollateralUsd);\\n    error InvalidDecreasePositionSwapType(uint256 decreasePositionSwapType);\\n    error PositionShouldNotBeLiquidated(\\n        string reason,\\n        int256 remainingCollateralUsd,\\n        int256 minCollateralUsd,\\n        int256 minCollateralUsdForLeverage\\n    );\\n\\n    // IncreasePositionUtils errors\\n    error InsufficientCollateralAmount(uint256 collateralAmount, int256 collateralDeltaAmount);\\n    error InsufficientCollateralUsd(int256 remainingCollateralUsd);\\n\\n    // PositionStoreUtils errors\\n    error PositionNotFound(bytes32 key);\\n\\n    // PositionUtils errors\\n    error LiquidatablePosition(\\n        string reason,\\n        int256 remainingCollateralUsd,\\n        int256 minCollateralUsd,\\n        int256 minCollateralUsdForLeverage\\n    );\\n\\n    error EmptyPosition();\\n    error InvalidPositionSizeValues(uint256 sizeInUsd, uint256 sizeInTokens);\\n    error MinPositionSize(uint256 positionSizeInUsd, uint256 minPositionSizeUsd);\\n\\n    // PositionPricingUtils errors\\n    error UsdDeltaExceedsLongOpenInterest(int256 usdDelta, uint256 longOpenInterest);\\n    error UsdDeltaExceedsShortOpenInterest(int256 usdDelta, uint256 shortOpenInterest);\\n\\n    // ShiftStoreUtils errors\\n    error ShiftNotFound(bytes32 key);\\n\\n    // ShiftUtils errors\\n    error EmptyShift();\\n    error EmptyShiftAmount();\\n    error ShiftFromAndToMarketAreEqual(address market);\\n    error LongTokensAreNotEqual(address fromMarketLongToken, address toMarketLongToken);\\n    error ShortTokensAreNotEqual(address fromMarketLongToken, address toMarketLongToken);\\n    error BridgeOutNotSupportedDuringShift();\\n\\n    // SwapPricingUtils errors\\n    error UsdDeltaExceedsPoolValue(int256 usdDelta, uint256 poolUsd);\\n\\n    // RoleModule errors\\n    error Unauthorized(address msgSender, string role);\\n\\n    // RoleStore errors\\n    error ThereMustBeAtLeastOneRoleAdmin();\\n    error ThereMustBeAtLeastOneTimelockMultiSig();\\n\\n    // ExchangeRouter errors\\n    error InvalidClaimFundingFeesInput(uint256 marketsLength, uint256 tokensLength);\\n    error InvalidClaimCollateralInput(uint256 marketsLength, uint256 tokensLength, uint256 timeKeysLength);\\n    error InvalidClaimAffiliateRewardsInput(uint256 marketsLength, uint256 tokensLength);\\n    error InvalidClaimUiFeesInput(uint256 marketsLength, uint256 tokensLength);\\n\\n    // SwapUtils errors\\n    error InvalidTokenIn(address tokenIn, address market);\\n    error InsufficientOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\\n    error InsufficientSwapOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\\n    error DuplicatedMarketInSwapPath(address market);\\n    error SwapPriceImpactExceedsAmountIn(uint256 amountAfterFees, int256 negativeImpactAmount);\\n\\n    // SubaccountRouter errors\\n    error InvalidReceiverForSubaccountOrder(address receiver, address expectedReceiver);\\n    error InvalidCancellationReceiverForSubaccountOrder(address cancellationReceiver, address expectedCancellationReceiver);\\n\\n    // SubaccountUtils errors\\n    error SubaccountNotAuthorized(address account, address subaccount);\\n    error MaxSubaccountActionCountExceeded(address account, address subaccount, uint256 count, uint256 maxCount);\\n    error SubaccountApprovalExpired(address account, address subaccount, uint256 deadline, uint256 currentTimestamp);\\n    error SubaccountIntegrationIdDisabled(bytes32 integrationId);\\n\\n    // TokenUtils errors\\n    error TokenTransferError(address token, address receiver, uint256 amount);\\n    error EmptyHoldingAddress();\\n    // Note that Transfer is misspelled as Tranfer in the EmptyTokenTranferGasLimit error\\n    // some contracts with this error cannot be re-deployed so it has been left as is\\n    error EmptyTokenTranferGasLimit(address token);\\n\\n    // AccountUtils errors\\n    error EmptyAccount();\\n    error EmptyReceiver();\\n    error DataListLengthExceeded();\\n\\n    // ClaimHandler errors\\n    error EmptyAmount();\\n    error EmptyClaimableAmount(address token);\\n    error InvalidToken(address token);\\n    error InvalidParams(string reason);\\n    error InsufficientFunds(address token);\\n    error InvalidClaimTermsSignature(address recoveredSigner, address expectedSigner);\\n    error InvalidClaimTermsSignatureForContract(address expectedSigner);\\n    error DuplicateClaimTerms(uint256 existingDistributionId);\\n\\n    // Array errors\\n    error CompactedArrayOutOfBounds(\\n        uint256[] compactedValues,\\n        uint256 index,\\n        uint256 slotIndex,\\n        string label\\n    );\\n\\n    error ArrayOutOfBoundsUint256(\\n        uint256[] values,\\n        uint256 index,\\n        string label\\n    );\\n\\n    error ArrayOutOfBoundsBytes(\\n        bytes[] values,\\n        uint256 index,\\n        string label\\n    );\\n\\n    // WithdrawalHandler errors\\n    error SwapsNotAllowedForAtomicWithdrawal(uint256 longTokenSwapPathLength, uint256 shortTokenSwapPathLength);\\n\\n    // WithdrawalStoreUtils errors\\n    error WithdrawalNotFound(bytes32 key);\\n\\n    // WithdrawalUtils errors\\n    error EmptyWithdrawal();\\n    error EmptyWithdrawalAmount();\\n    error MinLongTokens(uint256 received, uint256 expected);\\n    error MinShortTokens(uint256 received, uint256 expected);\\n    error InsufficientMarketTokens(uint256 balance, uint256 expected);\\n    error InvalidPoolValueForWithdrawal(int256 poolValue);\\n    error MaxLendableFactorForWithdrawalsExceeded(uint256 poolUsd, uint256 maxLendableUsd, uint256 lentUsd);\\n\\n    // Uint256Mask errors\\n    error MaskIndexOutOfBounds(uint256 index, string label);\\n    error DuplicatedIndex(uint256 index, string label);\\n\\n    // Cast errors\\n    error Uint256AsBytesLengthExceeds32Bytes(uint256 length);\\n\\n    // ConfigSyncer errors\\n    error SyncConfigInvalidInputLengths(uint256 marketsLength, uint256 parametersLength);\\n    error SyncConfigUpdatesDisabledForMarket(address market);\\n    error SyncConfigUpdatesDisabledForParameter(string parameter);\\n    error SyncConfigUpdatesDisabledForMarketParameter(address market, string parameter);\\n    error SyncConfigInvalidMarketFromData(address market, address marketFromData);\\n\\n    // Reader errors\\n    error EmptyMarketPrice(address market);\\n\\n    // Multichain errors\\n    error InvalidTransferRequestsLength();\\n    error EmptyMultichainTransferInAmount(address account, address token);\\n    error EmptyMultichainTransferOutAmount(address account, address token);\\n    error InsufficientMultichainBalance(address account, address token, uint256 balance, uint256 amount);\\n    error InvalidSrcChainId(uint256 srcChainId);\\n    error InvalidEid(uint256 eid);\\n    error InvalidDestinationChainId(uint256 desChainId);\\n    error TokenPermitsNotAllowedForMultichain();\\n    error InvalidInitializer();\\n    error InvalidMultichainProvider(address provider);\\n    error InvalidMultichainEndpoint(address endpoint);\\n    error ReferralCodeAlreadyExists(bytes32 code);\\n    error UnableToPayOrderFee();\\n    error UnableToPayOrderFeeFromCollateral();\\n    error InvalidBridgeOutToken(address token);\\n    error InsufficientFee(uint256 feeProvided, uint256 feeRequired);\\n\\n    enum SignatureType {\\n        Call,\\n        SubaccountApproval\\n    }\\n\\n    // Gelato relay errors\\n    error InvalidSignature(string signatureType);\\n    error InvalidRecoveredSigner(string signatureType, address recovered, address recoveredFromMinified, address expectedSigner);\\n    // User sent incorrect fee token or incorrect swap path\\n    error UnexpectedRelayFeeTokenAfterSwap(address feeToken, address expectedFeeToken);\\n    error UnexpectedRelayFeeToken(address feeToken, address expectedFeeToken);\\n    // Contract received unsupported fee token from Gelato relay\\n    error UnsupportedRelayFeeToken(address feeToken, address expectedFeeToken);\\n    error InvalidPermitSpender(address spender, address expectedSpender);\\n    error InvalidUserDigest(bytes32 digest);\\n    error SubaccountApprovalDeadlinePassed(uint256 currentTimestamp, uint256 deadline);\\n    error InvalidSubaccountApprovalNonce(uint256 storedNonce, uint256 nonce);\\n    error InvalidSubaccountApprovalDesChainId(uint256 desChainId);\\n    error DeadlinePassed(uint256 currentTimestamp, uint256 deadline);\\n    error InsufficientRelayFee(uint256 requiredRelayFee, uint256 availableFeeAmount);\\n    error InvalidSubaccountApprovalSubaccount();\\n    error NonEmptyExternalCallsForSubaccountOrder();\\n\\n    // EventUtils error\\n    error EventItemNotFound(string key);\\n\\n    // EdgeOracle verifier errors\\n    error InvalidTrustedSignerAddress();\\n    error InvalidEdgeSigner();\\n    error InvalidEdgeSignature(uint256 recoverError);\\n    error InvalidEdgeDataStreamBidAsk(address token, uint256 bid, uint256 ask);\\n    error InvalidEdgeDataStreamPrices(address token, uint256 bid, uint256 ask);\\n    error InvalidEdgeDataStreamExpo(int256 expo);\\n    error RelayEmptyBatch();\\n    error RelayCalldataTooLong(uint256 calldataLength);\\n    error InvalidExternalCalls(uint256 sendTokensLength, uint256 sendAmountsLength);\\n    error MaxRelayFeeSwapForSubaccountExceeded(uint256 feeUsd, uint256 maxFeeUsd);\\n\\n    error RemovalShouldNotBeSkipped(bytes32 listKey, bytes32 entityKey);\\n\\n    // MultichainReader errors\\n    error InsufficientMultichainNativeFee(uint256 msgValue);\\n    error EmptyPeer(uint32 eid);\\n\\n    // FeeDistributor errors\\n    error FeeDistributionAlreadyCompleted(uint256 lastDistributionTime, uint256 startOfCurrentWeek);\\n    error OutdatedReadResponse(uint256 timestamp);\\n    error InvalidDistributionState(uint256 distributionStateUint);\\n    error BridgedAmountNotSufficient(uint256 minRequiredFeeAmount, uint256 currentChainFeeAmount);\\n    error BridgingTransactionFailed(bytes result);\\n    error MaxWntReferralRewardsInUsdAmountExceeded(uint256 wntReferralRewardsInUsd, uint256 maxWntReferralRewardsInUsdAmount);\\n    error MaxWntReferralRewardsInUsdExceeded(uint256 wntReferralRewardsInUsd, uint256 maxWntReferralRewardsInUsd);\\n    error MaxEsGmxReferralRewardsAmountExceeded(uint256 tokensForReferralRewards, uint256 maxEsGmxReferralRewards);\\n    error MaxReferralRewardsExceeded(address token, uint256 cumulativeTransferAmount, uint256 tokensForReferralRewards);\\n    error MaxWntFromTreasuryExceeded(uint256 maxWntFromTreasury, uint256 additionalWntFromTreasury);\\n    error KeeperArrayLengthMismatch(uint256 keepersLength, uint256 keeperTargetBalancesLength, uint256 keeperVersionsLength);\\n    error SendEthToKeeperFailed(address keeper, uint256 sendAmount, bytes result);\\n    error KeeperAmountMismatch(uint256 wntForKeepers, uint256 wntToKeepers);\\n    error AttemptedBridgeAmountTooHigh(uint256 minRequiredFeeAmount, uint256 feeAmountCurrentChain, uint256 amountToBridgeOut);\\n    error InvalidReferralRewardToken(address token);\\n    error BridgingBalanceArrayMismatch(uint256 balancesLength, uint256 targetBalancesLength);\\n    error ZeroTreasuryAddress();\\n}\\n\",\"keccak256\":\"0x4c9e9fdbf998ce32c8a06d5cb2917d277138c9e127c0dbe3a711ca0dfda8ddaf\",\"license\":\"BUSL-1.1\"},\"contracts/event/EventEmitter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../role/RoleModule.sol\\\";\\nimport \\\"./EventUtils.sol\\\";\\n\\n// @title EventEmitter\\n// @dev Contract to emit events\\n// This allows main events to be emitted from a single contract\\n// Logic contracts can be updated while re-using the same eventEmitter contract\\n// Peripheral services like monitoring or analytics would be able to continue\\n// to work without an update and without segregating historical data\\ncontract EventEmitter is RoleModule {\\n    event EventLog(\\n        address msgSender,\\n        string eventName,\\n        string indexed eventNameHash,\\n        EventUtils.EventLogData eventData\\n    );\\n\\n    event EventLog1(\\n        address msgSender,\\n        string eventName,\\n        string indexed eventNameHash,\\n        bytes32 indexed topic1,\\n        EventUtils.EventLogData eventData\\n    );\\n\\n    event EventLog2(\\n        address msgSender,\\n        string eventName,\\n        string indexed eventNameHash,\\n        bytes32 indexed topic1,\\n        bytes32 indexed topic2,\\n        EventUtils.EventLogData eventData\\n    );\\n\\n    constructor(RoleStore _roleStore) RoleModule(_roleStore) {}\\n\\n    // @dev emit a general event log\\n    // @param eventName the name of the event\\n    // @param eventData the event data\\n    function emitEventLog(\\n        string memory eventName,\\n        EventUtils.EventLogData memory eventData\\n    ) external onlyController {\\n        emit EventLog(\\n            msg.sender,\\n            eventName,\\n            eventName,\\n            eventData\\n        );\\n    }\\n\\n    // @dev emit a general event log\\n    // @param eventName the name of the event\\n    // @param topic1 topic1 for indexing\\n    // @param eventData the event data\\n    function emitEventLog1(\\n        string memory eventName,\\n        bytes32 topic1,\\n        EventUtils.EventLogData memory eventData\\n    ) external onlyController {\\n        emit EventLog1(\\n            msg.sender,\\n            eventName,\\n            eventName,\\n            topic1,\\n            eventData\\n        );\\n    }\\n\\n    // @dev emit a general event log\\n    // @param eventName the name of the event\\n    // @param topic1 topic1 for indexing\\n    // @param topic2 topic2 for indexing\\n    // @param eventData the event data\\n    function emitEventLog2(\\n        string memory eventName,\\n        bytes32 topic1,\\n        bytes32 topic2,\\n        EventUtils.EventLogData memory eventData\\n    ) external onlyController {\\n        emit EventLog2(\\n            msg.sender,\\n            eventName,\\n            eventName,\\n            topic1,\\n            topic2,\\n            eventData\\n        );\\n    }\\n\\n\\n\\n    // @dev event log for general use\\n    // @param topic1 event topic 1\\n    // @param data additional data\\n    function emitDataLog1(bytes32 topic1, bytes memory data) external onlyController {\\n        uint256 len = data.length;\\n        assembly {\\n            log1(add(data, 32), len, topic1)\\n        }\\n    }\\n\\n    // @dev event log for general use\\n    // @param topic1 event topic 1\\n    // @param topic2 event topic 2\\n    // @param data additional data\\n    function emitDataLog2(bytes32 topic1, bytes32 topic2, bytes memory data) external onlyController {\\n        uint256 len = data.length;\\n        assembly {\\n            log2(add(data, 32), len, topic1, topic2)\\n        }\\n    }\\n\\n    // @dev event log for general use\\n    // @param topic1 event topic 1\\n    // @param topic2 event topic 2\\n    // @param topic3 event topic 3\\n    // @param data additional data\\n    function emitDataLog3(bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes memory data) external onlyController {\\n        uint256 len = data.length;\\n        assembly {\\n            log3(add(data, 32), len, topic1, topic2, topic3)\\n        }\\n    }\\n\\n    // @dev event log for general use\\n    // @param topic1 event topic 1\\n    // @param topic2 event topic 2\\n    // @param topic3 event topic 3\\n    // @param topic4 event topic 4\\n    // @param data additional data\\n    function emitDataLog4(bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4, bytes memory data) external onlyController {\\n        uint256 len = data.length;\\n        assembly {\\n            log4(add(data, 32), len, topic1, topic2, topic3, topic4)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8a99c1d3590daa8030345ffb09e3f769a93e0178e4c85986dc0e08cc84e8f82c\",\"license\":\"BUSL-1.1\"},\"contracts/event/EventUtils.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../error/Errors.sol\\\";\\nimport \\\"../utils/StringUtils.sol\\\";\\n\\nlibrary EventUtils {\\n\\n    struct EmitPositionDecreaseParams {\\n        bytes32 key;\\n        address account;\\n        address market;\\n        address collateralToken;\\n        bool isLong;\\n    }\\n\\n    struct EventLogData {\\n        AddressItems addressItems;\\n        UintItems uintItems;\\n        IntItems intItems;\\n        BoolItems boolItems;\\n        Bytes32Items bytes32Items;\\n        BytesItems bytesItems;\\n        StringItems stringItems;\\n    }\\n\\n    struct AddressItems {\\n        AddressKeyValue[] items;\\n        AddressArrayKeyValue[] arrayItems;\\n    }\\n\\n    struct UintItems {\\n        UintKeyValue[] items;\\n        UintArrayKeyValue[] arrayItems;\\n    }\\n\\n    struct IntItems {\\n        IntKeyValue[] items;\\n        IntArrayKeyValue[] arrayItems;\\n    }\\n\\n    struct BoolItems {\\n        BoolKeyValue[] items;\\n        BoolArrayKeyValue[] arrayItems;\\n    }\\n\\n    struct Bytes32Items {\\n        Bytes32KeyValue[] items;\\n        Bytes32ArrayKeyValue[] arrayItems;\\n    }\\n\\n    struct BytesItems {\\n        BytesKeyValue[] items;\\n        BytesArrayKeyValue[] arrayItems;\\n    }\\n\\n    struct StringItems {\\n        StringKeyValue[] items;\\n        StringArrayKeyValue[] arrayItems;\\n    }\\n\\n    struct AddressKeyValue {\\n        string key;\\n        address value;\\n    }\\n\\n    struct AddressArrayKeyValue {\\n        string key;\\n        address[] value;\\n    }\\n\\n    struct UintKeyValue {\\n        string key;\\n        uint256 value;\\n    }\\n\\n    struct UintArrayKeyValue {\\n        string key;\\n        uint256[] value;\\n    }\\n\\n    struct IntKeyValue {\\n        string key;\\n        int256 value;\\n    }\\n\\n    struct IntArrayKeyValue {\\n        string key;\\n        int256[] value;\\n    }\\n\\n    struct BoolKeyValue {\\n        string key;\\n        bool value;\\n    }\\n\\n    struct BoolArrayKeyValue {\\n        string key;\\n        bool[] value;\\n    }\\n\\n    struct Bytes32KeyValue {\\n        string key;\\n        bytes32 value;\\n    }\\n\\n    struct Bytes32ArrayKeyValue {\\n        string key;\\n        bytes32[] value;\\n    }\\n\\n    struct BytesKeyValue {\\n        string key;\\n        bytes value;\\n    }\\n\\n    struct BytesArrayKeyValue {\\n        string key;\\n        bytes[] value;\\n    }\\n\\n    struct StringKeyValue {\\n        string key;\\n        string value;\\n    }\\n\\n    struct StringArrayKeyValue {\\n        string key;\\n        string[] value;\\n    }\\n\\n    function initItems(AddressItems memory items, uint256 size) internal pure {\\n        items.items = new EventUtils.AddressKeyValue[](size);\\n    }\\n\\n    function initArrayItems(AddressItems memory items, uint256 size) internal pure {\\n        items.arrayItems = new EventUtils.AddressArrayKeyValue[](size);\\n    }\\n\\n    function setItem(AddressItems memory items, uint256 index, string memory key, address value) internal pure {\\n        items.items[index].key = key;\\n        items.items[index].value = value;\\n    }\\n\\n    function setItem(AddressItems memory items, uint256 index, string memory key, address[] memory value) internal pure {\\n        items.arrayItems[index].key = key;\\n        items.arrayItems[index].value = value;\\n    }\\n\\n    function get(AddressItems memory addresses, string memory key) external pure returns(address) {\\n        (bool found, address value) = getWithoutRevert(addresses, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getWithoutRevert(AddressItems memory addresses, string memory key) public pure returns(bool, address) {\\n        for (uint i = 0; i < addresses.items.length; i++) {\\n            if (compareStrings(addresses.items[i].key, key)) {\\n                return (true, addresses.items[i].value);\\n            }\\n        }\\n        return (false, address(0));\\n    }\\n\\n    function getArray(AddressItems memory addresses, string memory key) external pure\\n    returns(address[] memory) {\\n        (bool found, address[] memory value) = getArrayWithoutRevert(addresses, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getArrayWithoutRevert(AddressItems memory addresses, string memory key) public pure\\n    returns(bool, address[] memory) {\\n        for (uint i = 0; i < addresses.arrayItems.length; i++) {\\n            if (compareStrings(addresses.arrayItems[i].key, key)) {\\n                return (true, addresses.arrayItems[i].value);\\n            }\\n        }\\n        address[] memory empty;\\n        return (false, empty);\\n    }\\n\\n    function initItems(UintItems memory items, uint256 size) internal pure {\\n        items.items = new EventUtils.UintKeyValue[](size);\\n    }\\n\\n    function initArrayItems(UintItems memory items, uint256 size) internal pure {\\n        items.arrayItems = new EventUtils.UintArrayKeyValue[](size);\\n    }\\n\\n    function setItem(UintItems memory items, uint256 index, string memory key, uint256 value) internal pure {\\n        items.items[index].key = key;\\n        items.items[index].value = value;\\n    }\\n\\n    function setItem(UintItems memory items, uint256 index, string memory key, uint256[] memory value) internal pure {\\n        items.arrayItems[index].key = key;\\n        items.arrayItems[index].value = value;\\n    }\\n\\n    function get(UintItems memory items, string memory key) external pure returns(uint256) {\\n        (bool found, uint256 value) = getWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getWithoutRevert(UintItems memory items, string memory key) public pure returns(bool, uint256) {\\n        for (uint i = 0; i < items.items.length; i++) {\\n            if (compareStrings(items.items[i].key, key)) {\\n                return (true, items.items[i].value);\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    function getArray(UintItems memory items, string memory key) external pure\\n    returns(uint256[] memory) {\\n        (bool found, uint256[] memory value) = getArrayWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getArrayWithoutRevert(UintItems memory items, string memory key) public pure\\n    returns(bool, uint256[] memory) {\\n        for (uint i = 0; i < items.arrayItems.length; i++) {\\n            if (compareStrings(items.arrayItems[i].key, key)) {\\n                return (true, items.arrayItems[i].value);\\n            }\\n        }\\n        uint256[] memory empty;\\n        return (false, empty);\\n    }\\n\\n    function initItems(IntItems memory items, uint256 size) internal pure {\\n        items.items = new EventUtils.IntKeyValue[](size);\\n    }\\n\\n    function initArrayItems(IntItems memory items, uint256 size) internal pure {\\n        items.arrayItems = new EventUtils.IntArrayKeyValue[](size);\\n    }\\n\\n    function setItem(IntItems memory items, uint256 index, string memory key, int256 value) internal pure {\\n        items.items[index].key = key;\\n        items.items[index].value = value;\\n    }\\n\\n    function setItem(IntItems memory items, uint256 index, string memory key, int256[] memory value) internal pure {\\n        items.arrayItems[index].key = key;\\n        items.arrayItems[index].value = value;\\n    }\\n\\n    function get(IntItems memory items, string memory key) external pure returns(int256) {\\n        (bool found, int256 value) = getWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getWithoutRevert(IntItems memory items, string memory key) public pure returns(bool, int256) {\\n        for (uint i = 0; i < items.items.length; i++) {\\n            if (compareStrings(items.items[i].key, key)) {\\n                return (true, items.items[i].value);\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    function getArray(IntItems memory items, string memory key) external pure\\n    returns(int256[] memory) {\\n        (bool found, int256[] memory value) = getArrayWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getArrayWithoutRevert(IntItems memory items, string memory key) public pure\\n    returns(bool, int256[] memory) {\\n        for (uint i = 0; i < items.arrayItems.length; i++) {\\n            if (compareStrings(items.arrayItems[i].key, key)) {\\n                return (true, items.arrayItems[i].value);\\n            }\\n        }\\n        int256[] memory empty;\\n        return (false, empty);\\n    }\\n\\n    function initItems(BoolItems memory items, uint256 size) internal pure {\\n        items.items = new EventUtils.BoolKeyValue[](size);\\n    }\\n\\n    function initArrayItems(BoolItems memory items, uint256 size) internal pure {\\n        items.arrayItems = new EventUtils.BoolArrayKeyValue[](size);\\n    }\\n\\n    function setItem(BoolItems memory items, uint256 index, string memory key, bool value) internal pure {\\n        items.items[index].key = key;\\n        items.items[index].value = value;\\n    }\\n\\n    function setItem(BoolItems memory items, uint256 index, string memory key, bool[] memory value) internal pure {\\n        items.arrayItems[index].key = key;\\n        items.arrayItems[index].value = value;\\n    }\\n\\n    function get(BoolItems memory items, string memory key) external pure returns(bool) {\\n        (bool found, bool value) = getWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getWithoutRevert(BoolItems memory items, string memory key) public pure returns(bool, bool) {\\n        for (uint i = 0; i < items.items.length; i++) {\\n            if (compareStrings(items.items[i].key, key)) {\\n                return (true, items.items[i].value);\\n            }\\n        }\\n        return (false, false);\\n    }\\n\\n    function getArray(BoolItems memory items, string memory key) external pure\\n    returns(bool[] memory) {\\n        (bool found, bool[] memory value) = getArrayWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getArrayWithoutRevert(BoolItems memory items, string memory key) public pure\\n    returns(bool, bool[] memory) {\\n        for (uint i = 0; i < items.arrayItems.length; i++) {\\n            if (compareStrings(items.arrayItems[i].key, key)) {\\n                return (true, items.arrayItems[i].value);\\n            }\\n        }\\n        bool[] memory empty;\\n        return (false, empty);\\n    }\\n\\n    function initItems(Bytes32Items memory items, uint256 size) internal pure {\\n        items.items = new EventUtils.Bytes32KeyValue[](size);\\n    }\\n\\n    function initArrayItems(Bytes32Items memory items, uint256 size) internal pure {\\n        items.arrayItems = new EventUtils.Bytes32ArrayKeyValue[](size);\\n    }\\n\\n    function setItem(Bytes32Items memory items, uint256 index, string memory key, bytes32 value) internal pure {\\n        items.items[index].key = key;\\n        items.items[index].value = value;\\n    }\\n\\n    function setItem(Bytes32Items memory items, uint256 index, string memory key, bytes32[] memory value) internal pure {\\n        items.arrayItems[index].key = key;\\n        items.arrayItems[index].value = value;\\n    }\\n\\n    function get(Bytes32Items memory items, string memory key) external pure returns(bytes32) {\\n        (bool found, bytes32 value) = getWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getWithoutRevert(Bytes32Items memory items, string memory key) public pure returns(bool, bytes32) {\\n        for (uint i = 0; i < items.items.length; i++) {\\n            if (compareStrings(items.items[i].key, key)) {\\n                return (true, items.items[i].value);\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    function getArray(Bytes32Items memory items, string memory key) external pure\\n    returns(bytes32[] memory) {\\n        (bool found, bytes32[] memory value) = getArrayWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getArrayWithoutRevert(Bytes32Items memory items, string memory key) public pure\\n    returns(bool, bytes32[] memory) {\\n        for (uint i = 0; i < items.arrayItems.length; i++) {\\n            if (compareStrings(items.arrayItems[i].key, key)) {\\n                return (true, items.arrayItems[i].value);\\n            }\\n        }\\n        bytes32[] memory empty;\\n        return (false, empty);\\n    }\\n\\n    function initItems(BytesItems memory items, uint256 size) internal pure {\\n        items.items = new EventUtils.BytesKeyValue[](size);\\n    }\\n\\n    function initArrayItems(BytesItems memory items, uint256 size) internal pure {\\n        items.arrayItems = new EventUtils.BytesArrayKeyValue[](size);\\n    }\\n\\n    function setItem(BytesItems memory items, uint256 index, string memory key, bytes memory value) internal pure {\\n        items.items[index].key = key;\\n        items.items[index].value = value;\\n    }\\n\\n    function setItem(BytesItems memory items, uint256 index, string memory key, bytes[] memory value) internal pure {\\n        items.arrayItems[index].key = key;\\n        items.arrayItems[index].value = value;\\n    }\\n\\n    function get(BytesItems memory items, string memory key) external pure returns(bytes memory) {\\n        (bool found, bytes memory value) = getWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getWithoutRevert(BytesItems memory items, string memory key) public pure returns(bool, bytes memory) {\\n        for (uint i = 0; i < items.items.length; i++) {\\n            if (compareStrings(items.items[i].key, key)) {\\n                return (true, items.items[i].value);\\n            }\\n        }\\n        return (false, \\\"\\\");\\n    }\\n\\n    function getArray(BytesItems memory items, string memory key) external pure\\n    returns(bytes[] memory) {\\n        (bool found, bytes[] memory value) = getArrayWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getArrayWithoutRevert(BytesItems memory items, string memory key) public pure\\n    returns(bool, bytes[] memory) {\\n        for (uint i = 0; i < items.arrayItems.length; i++) {\\n            if (compareStrings(items.arrayItems[i].key, key)) {\\n                return (true, items.arrayItems[i].value);\\n            }\\n        }\\n        bytes[] memory empty;\\n        return (false, empty);\\n    }\\n\\n    function initItems(StringItems memory items, uint256 size) internal pure {\\n        items.items = new EventUtils.StringKeyValue[](size);\\n    }\\n\\n    function initArrayItems(StringItems memory items, uint256 size) internal pure {\\n        items.arrayItems = new EventUtils.StringArrayKeyValue[](size);\\n    }\\n\\n    function setItem(StringItems memory items, uint256 index, string memory key, string memory value) internal pure {\\n        items.items[index].key = key;\\n        items.items[index].value = value;\\n    }\\n\\n    function setItem(StringItems memory items, uint256 index, string memory key, string[] memory value) internal pure {\\n        items.arrayItems[index].key = key;\\n        items.arrayItems[index].value = value;\\n    }\\n\\n    function get(StringItems memory items, string memory key) external pure returns(string memory) {\\n        (bool found, string memory value) = getWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getWithoutRevert(StringItems memory items, string memory key) public pure returns(bool, string memory) {\\n        for (uint i = 0; i < items.items.length; i++) {\\n            if (compareStrings(items.items[i].key, key)) {\\n                return (true, items.items[i].value);\\n            }\\n        }\\n        return (false, \\\"\\\");\\n    }\\n\\n    function getArray(StringItems memory items, string memory key) external pure\\n    returns(string[] memory) {\\n        (bool found, string[] memory value) = getArrayWithoutRevert(items, key);\\n        if (!found) {\\n            revert Errors.EventItemNotFound(key);\\n        }\\n        return value;\\n    }\\n\\n    function getArrayWithoutRevert(StringItems memory items, string memory key) public pure\\n    returns(bool, string[] memory) {\\n        for (uint i = 0; i < items.arrayItems.length; i++) {\\n            if (compareStrings(items.arrayItems[i].key, key)) {\\n                return (true, items.arrayItems[i].value);\\n            }\\n        }\\n        string[] memory empty;\\n        return (false, empty);\\n    }\\n\\n    function compareStrings(string memory a, string memory b) public pure returns (bool) {\\n        return StringUtils.compareStrings(a, b);\\n    }\\n}\\n\",\"keccak256\":\"0x4fc9dd0bed17a086fc9f5c5e785be7e6ab2ba21ad19db5b1c4337bf9c322fd35\",\"license\":\"BUSL-1.1\"},\"contracts/role/Role.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Role\\n * @dev Library for role keys\\n */\\nlibrary Role {\\n    /**\\n     * @dev The ROLE_ADMIN role.\\n     * Hash: 0x56908b85b56869d7c69cd020749874f238259af9646ca930287866cdd660b7d9\\n     */\\n    bytes32 public constant ROLE_ADMIN = keccak256(abi.encode(\\\"ROLE_ADMIN\\\"));\\n\\n    /**\\n     * @dev The TIMELOCK_ADMIN role.\\n     * Hash: 0xf49b0c86b385620e25b0985905d1a112a5f1bc1d51a7a292a8cdf112b3a7c47c\\n     */\\n    bytes32 public constant TIMELOCK_ADMIN = keccak256(abi.encode(\\\"TIMELOCK_ADMIN\\\"));\\n\\n    /**\\n     * @dev The TIMELOCK_MULTISIG role.\\n     * Hash: 0xe068a8d811c3c8290a8be34607cfa3184b26ffb8dea4dde7a451adfba9fa173a\\n     */\\n    bytes32 public constant TIMELOCK_MULTISIG = keccak256(abi.encode(\\\"TIMELOCK_MULTISIG\\\"));\\n\\n    /**\\n     * @dev The CONFIG_KEEPER role.\\n     * Hash: 0x901fb3de937a1dcb6ecaf26886fda47a088e74f36232a0673eade97079dc225b\\n     */\\n    bytes32 public constant CONFIG_KEEPER = keccak256(abi.encode(\\\"CONFIG_KEEPER\\\"));\\n\\n    /**\\n     * @dev The LIMITED_CONFIG_KEEPER role.\\n     * Hash: 0xb49beded4d572a2d32002662fc5c735817329f4337b3a488aab0b5e835c01ba7\\n     */\\n    bytes32 public constant LIMITED_CONFIG_KEEPER = keccak256(abi.encode(\\\"LIMITED_CONFIG_KEEPER\\\"));\\n\\n    /**\\n     * @dev The CONTROLLER role.\\n     * Hash: 0x97adf037b2472f4a6a9825eff7d2dd45e37f2dc308df2a260d6a72af4189a65b\\n     */\\n    bytes32 public constant CONTROLLER = keccak256(abi.encode(\\\"CONTROLLER\\\"));\\n\\n    /**\\n     * @dev The GOV_TOKEN_CONTROLLER role.\\n     * Hash: 0x16a157db08319d4eaf6b157a71f5d2e18c6500cab8a25bee0b4f9c753cb13690\\n     */\\n    bytes32 public constant GOV_TOKEN_CONTROLLER = keccak256(abi.encode(\\\"GOV_TOKEN_CONTROLLER\\\"));\\n\\n    /**\\n     * @dev The ROUTER_PLUGIN role.\\n     * Hash: 0xc82e6cc76072f8edb32d42796e58e13ab6e145524eb6b36c073be82f20d410f3\\n     */\\n    bytes32 public constant ROUTER_PLUGIN = keccak256(abi.encode(\\\"ROUTER_PLUGIN\\\"));\\n\\n    /**\\n     * @dev The MARKET_KEEPER role.\\n     * Hash: 0xd66692c70b60cf1337e643d6a6473f6865d8c03f3c26b460df3d19b504fb46ae\\n     */\\n    bytes32 public constant MARKET_KEEPER = keccak256(abi.encode(\\\"MARKET_KEEPER\\\"));\\n\\n    /**\\n     * @dev The FEE_KEEPER role.\\n     * Hash: 0xe0ff4cc0c6ecffab6db3f63ea62dd53f8091919ac57669f1bb3d9828278081d8\\n     */\\n    bytes32 public constant FEE_KEEPER = keccak256(abi.encode(\\\"FEE_KEEPER\\\"));\\n\\n    /**\\n     * @dev The FEE_DISTRIBUTION_KEEPER role.\\n     * Hash: 0xc23a98a1bf683201c11eeeb8344052ad3bc603c8ddcad06093edc1e8dafa96a2\\n     */\\n    bytes32 public constant FEE_DISTRIBUTION_KEEPER = keccak256(abi.encode(\\\"FEE_DISTRIBUTION_KEEPER\\\"));\\n\\n    /**\\n     * @dev The ORDER_KEEPER role.\\n     * Hash: 0x40a07f8f0fc57fcf18b093d96362a8e661eaac7b7e6edbf66f242111f83a6794\\n     */\\n    bytes32 public constant ORDER_KEEPER = keccak256(abi.encode(\\\"ORDER_KEEPER\\\"));\\n\\n    /**\\n     * @dev The FROZEN_ORDER_KEEPER role.\\n     * Hash: 0xcb6c7bc0d25d73c91008af44527b80c56dee4db8965845d926a25659a4a8bc07\\n     */\\n    bytes32 public constant FROZEN_ORDER_KEEPER = keccak256(abi.encode(\\\"FROZEN_ORDER_KEEPER\\\"));\\n\\n    /**\\n     * @dev The PRICING_KEEPER role.\\n     * Hash: 0x2700e36dc4e6a0daa977bffd4368adbd48f8058da74152919f91f58eddb42103\\n     */\\n    bytes32 public constant PRICING_KEEPER = keccak256(abi.encode(\\\"PRICING_KEEPER\\\"));\\n    /**\\n     * @dev The LIQUIDATION_KEEPER role.\\n     * Hash: 0x556c788ffc0574ec93966d808c170833d96489c9c58f5bcb3dadf711ba28720e\\n     */\\n    bytes32 public constant LIQUIDATION_KEEPER = keccak256(abi.encode(\\\"LIQUIDATION_KEEPER\\\"));\\n    /**\\n     * @dev The ADL_KEEPER role.\\n     * Hash: 0xb37d64edaeaf5e634c13682dbd813f5a12fec9eb4f74433a089e7a3c3289af91\\n     */\\n    bytes32 public constant ADL_KEEPER = keccak256(abi.encode(\\\"ADL_KEEPER\\\"));\\n    /**\\n     * @dev The CONTRIBUTOR_KEEPER role.\\n     * Hash: 0xfa89e7b5ea0a346d73c71d7d6a3512b9f2ea2c2e6c5fb8211ec351d35deef0f4\\n     */\\n    bytes32 public constant CONTRIBUTOR_KEEPER = keccak256(abi.encode(\\\"CONTRIBUTOR_KEEPER\\\"));\\n    /**\\n     * @dev The CONTRIBUTOR_DISTRIBUTOR role.\\n     * Hash: 0xcdf6da7ad30d8b9afea66fb1cb11b1b7d0b50e9b30b69561a3ca52c39251360c\\n     */\\n    bytes32 public constant CONTRIBUTOR_DISTRIBUTOR = keccak256(abi.encode(\\\"CONTRIBUTOR_DISTRIBUTOR\\\"));\\n\\n    /**\\n     * @dev The CLAIM_ADMIN role.\\n     * Hash: 0x3816efacf145d41a12de1ee8ae9dc340b887f4ca0f3bba62a645b2fefa4cab33\\n     */\\n    bytes32 public constant CLAIM_ADMIN = keccak256(abi.encode(\\\"CLAIM_ADMIN\\\"));\\n    /**\\n     * @dev The MULTICHAIN_READER role.\\n     * Hash: 0xdb34a94d601aa170c498f99c1628bd6182669f4ea4522eb87795649193ee93f8\\n     */\\n    bytes32 public constant MULTICHAIN_READER = keccak256(abi.encode(\\\"MULTICHAIN_READER\\\"));\\n}\\n\",\"keccak256\":\"0x9cdae2fd9f0dd3579ef80b29eccfe0b1107efc4e280870f86b0d764aa4c3d5f5\",\"license\":\"BUSL-1.1\"},\"contracts/role/RoleModule.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./RoleStore.sol\\\";\\n\\n/**\\n * @title RoleModule\\n * @dev Contract for role validation functions\\n */\\ncontract RoleModule {\\n    RoleStore public immutable roleStore;\\n\\n    /**\\n     * @dev Constructor that initializes the role store for this contract.\\n     *\\n     * @param _roleStore The contract instance to use as the role store.\\n     */\\n    constructor(RoleStore _roleStore) {\\n        roleStore = _roleStore;\\n    }\\n\\n    modifier onlySelfOrController() {\\n        if (msg.sender != address(this) && !roleStore.hasRole(msg.sender, Role.CONTROLLER)) {\\n            revert Errors.Unauthorized(msg.sender, \\\"SELF_OR_CONTROLLER\\\");\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows the contract's own address to call the function.\\n     */\\n    modifier onlySelf() {\\n        if (msg.sender != address(this)) {\\n            revert Errors.Unauthorized(msg.sender, \\\"SELF\\\");\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the TIMELOCK_MULTISIG role to call the function.\\n     */\\n    modifier onlyTimelockMultisig() {\\n        _validateRole(Role.TIMELOCK_MULTISIG, \\\"TIMELOCK_MULTISIG\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the TIMELOCK_ADMIN role to call the function.\\n     */\\n    modifier onlyTimelockAdmin() {\\n        _validateRole(Role.TIMELOCK_ADMIN, \\\"TIMELOCK_ADMIN\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the CONFIG_KEEPER role to call the function.\\n     */\\n    modifier onlyConfigKeeper() {\\n        _validateRole(Role.CONFIG_KEEPER, \\\"CONFIG_KEEPER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the LIMITED_CONFIG_KEEPER role to call the function.\\n     */\\n    modifier onlyLimitedConfigKeeper() {\\n        _validateRole(Role.LIMITED_CONFIG_KEEPER, \\\"LIMITED_CONFIG_KEEPER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the CONTROLLER role to call the function.\\n     */\\n    modifier onlyController() {\\n        _validateRole(Role.CONTROLLER, \\\"CONTROLLER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the GOV_TOKEN_CONTROLLER role to call the function.\\n     */\\n    modifier onlyGovTokenController() {\\n        _validateRole(Role.GOV_TOKEN_CONTROLLER, \\\"GOV_TOKEN_CONTROLLER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the ROUTER_PLUGIN role to call the function.\\n     */\\n    modifier onlyRouterPlugin() {\\n        _validateRole(Role.ROUTER_PLUGIN, \\\"ROUTER_PLUGIN\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the MARKET_KEEPER role to call the function.\\n     */\\n    modifier onlyMarketKeeper() {\\n        _validateRole(Role.MARKET_KEEPER, \\\"MARKET_KEEPER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the FEE_KEEPER role to call the function.\\n     */\\n    modifier onlyFeeKeeper() {\\n        _validateRole(Role.FEE_KEEPER, \\\"FEE_KEEPER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the FEE_DISTRIBUTION_KEEPER role to call the function.\\n     */\\n    modifier onlyFeeDistributionKeeper() {\\n        _validateRole(Role.FEE_DISTRIBUTION_KEEPER, \\\"FEE_DISTRIBUTION_KEEPER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the ORDER_KEEPER role to call the function.\\n     */\\n    modifier onlyOrderKeeper() {\\n        _validateRole(Role.ORDER_KEEPER, \\\"ORDER_KEEPER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the PRICING_KEEPER role to call the function.\\n     */\\n    modifier onlyPricingKeeper() {\\n        _validateRole(Role.PRICING_KEEPER, \\\"PRICING_KEEPER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the LIQUIDATION_KEEPER role to call the function.\\n     */\\n    modifier onlyLiquidationKeeper() {\\n        _validateRole(Role.LIQUIDATION_KEEPER, \\\"LIQUIDATION_KEEPER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the ADL_KEEPER role to call the function.\\n     */\\n    modifier onlyAdlKeeper() {\\n        _validateRole(Role.ADL_KEEPER, \\\"ADL_KEEPER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the CONTRIBUTOR_KEEPER role to call the function.\\n     */\\n    modifier onlyContributorKeeper() {\\n        _validateRole(Role.CONTRIBUTOR_KEEPER, \\\"CONTRIBUTOR_KEEPER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the CONTRIBUTOR_DISTRIBUTOR role to call the function.\\n     */\\n    modifier onlyContributorDistributor() {\\n        _validateRole(Role.CONTRIBUTOR_DISTRIBUTOR, \\\"CONTRIBUTOR_DISTRIBUTOR\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the CLAIM_ADMIN role to call the function.\\n     */\\n    modifier onlyClaimAdmin() {\\n        _validateRole(Role.CLAIM_ADMIN, \\\"CLAIM_ADMIN\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows addresses with the MULTICHAIN_READER role to call the function.\\n     */\\n    modifier onlyMultichainReader() {\\n        _validateRole(Role.MULTICHAIN_READER, \\\"MULTICHAIN_READER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Validates that the caller has the specified role.\\n     *\\n     * If the caller does not have the specified role, the transaction is reverted.\\n     *\\n     * @param role The key of the role to validate.\\n     * @param roleName The name of the role to validate.\\n     */\\n    function _validateRole(bytes32 role, string memory roleName) internal view {\\n        if (!roleStore.hasRole(msg.sender, role)) {\\n            revert Errors.Unauthorized(msg.sender, roleName);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc765f8f14eaaa274c68348a037738e9eab3aa8b65aa3cac4f9bbce578184072a\",\"license\":\"BUSL-1.1\"},\"contracts/role/RoleStore.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"../utils/EnumerableValues.sol\\\";\\nimport \\\"./Role.sol\\\";\\nimport \\\"../error/Errors.sol\\\";\\n\\n/**\\n * @title RoleStore\\n * @dev Stores roles and their members.\\n */\\ncontract RoleStore {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n    using EnumerableValues for EnumerableSet.AddressSet;\\n    using EnumerableValues for EnumerableSet.Bytes32Set;\\n\\n    EnumerableSet.Bytes32Set internal roles;\\n    mapping(bytes32 => EnumerableSet.AddressSet) internal roleMembers;\\n    // checking if an account has a role is a frequently used function\\n    // roleCache helps to save gas by offering a more efficient lookup\\n    // vs calling roleMembers[key].contains(account)\\n    mapping(address => mapping (bytes32 => bool)) roleCache;\\n\\n    modifier onlyRoleAdmin() {\\n        if (!hasRole(msg.sender, Role.ROLE_ADMIN)) {\\n            revert Errors.Unauthorized(msg.sender, \\\"ROLE_ADMIN\\\");\\n        }\\n        _;\\n    }\\n\\n    constructor() {\\n        _grantRole(msg.sender, Role.ROLE_ADMIN);\\n    }\\n\\n    /**\\n     * @dev Grants the specified role to the given account.\\n     *\\n     * @param account The address of the account.\\n     * @param roleKey The key of the role to grant.\\n     */\\n    function grantRole(address account, bytes32 roleKey) external onlyRoleAdmin {\\n        _grantRole(account, roleKey);\\n    }\\n\\n    /**\\n     * @dev Revokes the specified role from the given account.\\n     *\\n     * @param account The address of the account.\\n     * @param roleKey The key of the role to revoke.\\n     */\\n    function revokeRole(address account, bytes32 roleKey) external onlyRoleAdmin {\\n        _revokeRole(account, roleKey);\\n    }\\n\\n    /**\\n     * @dev Returns true if the given account has the specified role.\\n     *\\n     * @param account The address of the account.\\n     * @param roleKey The key of the role.\\n     * @return True if the account has the role, false otherwise.\\n     */\\n    function hasRole(address account, bytes32 roleKey) public view returns (bool) {\\n        return roleCache[account][roleKey];\\n    }\\n\\n    /**\\n     * @dev Returns the number of roles stored in the contract.\\n     *\\n     * @return The number of roles.\\n     */\\n    function getRoleCount() external view returns (uint256) {\\n        return roles.length();\\n    }\\n\\n    /**\\n     * @dev Returns the keys of the roles stored in the contract.\\n     *\\n     * @param start The starting index of the range of roles to return.\\n     * @param end The ending index of the range of roles to return.\\n     * @return The keys of the roles.\\n     */\\n    function getRoles(uint256 start, uint256 end) external view returns (bytes32[] memory) {\\n        return roles.valuesAt(start, end);\\n    }\\n\\n    /**\\n     * @dev Returns the number of members of the specified role.\\n     *\\n     * @param roleKey The key of the role.\\n     * @return The number of members of the role.\\n     */\\n    function getRoleMemberCount(bytes32 roleKey) external view returns (uint256) {\\n        return roleMembers[roleKey].length();\\n    }\\n\\n    /**\\n     * @dev Returns the members of the specified role.\\n     *\\n     * @param roleKey The key of the role.\\n     * @param start the start index, the value for this index will be included.\\n     * @param end the end index, the value for this index will not be included.\\n     * @return The members of the role.\\n     */\\n    function getRoleMembers(bytes32 roleKey, uint256 start, uint256 end) external view returns (address[] memory) {\\n        return roleMembers[roleKey].valuesAt(start, end);\\n    }\\n\\n    function _grantRole(address account, bytes32 roleKey) internal {\\n        roles.add(roleKey);\\n        roleMembers[roleKey].add(account);\\n        roleCache[account][roleKey] = true;\\n    }\\n\\n    function _revokeRole(address account, bytes32 roleKey) internal {\\n        roleMembers[roleKey].remove(account);\\n        roleCache[account][roleKey] = false;\\n\\n        if (roleMembers[roleKey].length() == 0) {\\n            if (roleKey == Role.ROLE_ADMIN) {\\n                revert Errors.ThereMustBeAtLeastOneRoleAdmin();\\n            }\\n            if (roleKey == Role.TIMELOCK_MULTISIG) {\\n                revert Errors.ThereMustBeAtLeastOneTimelockMultiSig();\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaa7be1876450ec19568c0e12e4238332c96eb921974a19c0e4a6fe1fb943bf6d\",\"license\":\"BUSL-1.1\"},\"contracts/utils/Calc.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\n/**\\n * @title Calc\\n * @dev Library for math functions\\n */\\nlibrary Calc {\\n    using SignedMath for int256;\\n    using SafeCast for uint256;\\n\\n    // this method assumes that min is less than max\\n    function boundMagnitude(int256 value, uint256 min, uint256 max) internal pure returns (int256) {\\n        uint256 magnitude = value.abs();\\n\\n        if (magnitude < min) {\\n            magnitude = min;\\n        }\\n\\n        if (magnitude > max) {\\n            magnitude = max;\\n        }\\n\\n        int256 sign = value == 0 ? int256(1) : value / value.abs().toInt256();\\n\\n        return magnitude.toInt256() * sign;\\n    }\\n\\n    /**\\n     * @dev Calculates the result of dividing the first number by the second number,\\n     * rounded up to the nearest integer.\\n     *\\n     * @param a the dividend\\n     * @param b the divisor\\n     * @return the result of dividing the first number by the second number, rounded up to the nearest integer\\n     */\\n    function roundUpDivision(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a + b - 1) / b;\\n    }\\n\\n    /**\\n     * Calculates the result of dividing the first number by the second number,\\n     * rounded up to the nearest integer.\\n     * The rounding is purely on the magnitude of a, if a is negative the result\\n     * is a larger magnitude negative\\n     *\\n     * @param a the dividend\\n     * @param b the divisor\\n     * @return the result of dividing the first number by the second number, rounded up to the nearest integer\\n     */\\n    function roundUpMagnitudeDivision(int256 a, uint256 b) internal pure returns (int256) {\\n        if (a < 0) {\\n            return (a - b.toInt256() + 1) / b.toInt256();\\n        }\\n\\n        return (a + b.toInt256() - 1) / b.toInt256();\\n    }\\n\\n    /**\\n     * Adds two numbers together and return a uint256 value, treating the second number as a signed integer.\\n     *\\n     * @param a the first number\\n     * @param b the second number\\n     * @return the result of adding the two numbers together\\n     */\\n    function sumReturnUint256(uint256 a, int256 b) internal pure returns (uint256) {\\n        if (b > 0) {\\n            return a + b.abs();\\n        }\\n\\n        return a - b.abs();\\n    }\\n\\n    /**\\n     * Adds two numbers together and return an int256 value, treating the second number as a signed integer.\\n     *\\n     * @param a the first number\\n     * @param b the second number\\n     * @return the result of adding the two numbers together\\n     */\\n    function sumReturnInt256(uint256 a, int256 b) internal pure returns (int256) {\\n        return a.toInt256() + b;\\n    }\\n\\n    /**\\n     * @dev Calculates the absolute difference between two numbers.\\n     *\\n     * @param a the first number\\n     * @param b the second number\\n     * @return the absolute difference between the two numbers\\n     */\\n    function diff(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a - b : b - a;\\n    }\\n\\n    /**\\n     * Adds two numbers together, the result is bounded to prevent overflows.\\n     *\\n     * @param a the first number\\n     * @param b the second number\\n     * @return the result of adding the two numbers together\\n     */\\n    function boundedAdd(int256 a, int256 b) internal pure returns (int256) {\\n        // if either a or b is zero or if the signs are different there should not be any overflows\\n        if (a == 0 || b == 0 || (a < 0 && b > 0) || (a > 0 && b < 0)) {\\n            return a + b;\\n        }\\n\\n        // if adding `b` to `a` would result in a value less than the min int256 value\\n        // then return the min int256 value\\n        if (a < 0 && b <= type(int256).min - a) {\\n            return type(int256).min;\\n        }\\n\\n        // if adding `b` to `a` would result in a value more than the max int256 value\\n        // then return the max int256 value\\n        if (a > 0 && b >= type(int256).max - a) {\\n            return type(int256).max;\\n        }\\n\\n        return a + b;\\n    }\\n\\n    /**\\n     * Returns a - b, the result is bounded to prevent overflows.\\n     * Note that this will revert if b is type(int256).min because of the usage of \\\"-b\\\".\\n     *\\n     * @param a the first number\\n     * @param b the second number\\n     * @return the bounded result of a - b\\n     */\\n    function boundedSub(int256 a, int256 b) internal pure returns (int256) {\\n        // if either a or b is zero or the signs are the same there should not be any overflow\\n        if (a == 0 || b == 0 || (a > 0 && b > 0) || (a < 0 && b < 0)) {\\n            return a - b;\\n        }\\n\\n        // if adding `-b` to `a` would result in a value greater than the max int256 value\\n        // then return the max int256 value\\n        if (a > 0 && -b >= type(int256).max - a) {\\n            return type(int256).max;\\n        }\\n\\n        // if subtracting `b` from `a` would result in a value less than the min int256 value\\n        // then return the min int256 value\\n        if (a < 0 && -b <= type(int256).min - a) {\\n            return type(int256).min;\\n        }\\n\\n        return a - b;\\n    }\\n\\n\\n    /**\\n     * Converts the given unsigned integer to a signed integer, using the given\\n     * flag to determine whether the result should be positive or negative.\\n     *\\n     * @param a the unsigned integer to convert\\n     * @param isPositive whether the result should be positive (if true) or negative (if false)\\n     * @return the signed integer representation of the given unsigned integer\\n     */\\n    function toSigned(uint256 a, bool isPositive) internal pure returns (int256) {\\n        if (isPositive) {\\n            return a.toInt256();\\n        } else {\\n            return -a.toInt256();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3848e1c51a6c77a1d6ec30bb052e97f6c39437110c773ebc06956ce5e4a54370\",\"license\":\"BUSL-1.1\"},\"contracts/utils/Cast.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../error/Errors.sol\\\";\\n\\n/**\\n * @title Cast\\n * @dev Library for casting functions\\n */\\nlibrary Cast {\\n    function toBytes32(address value) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a bytes array to a uint256.\\n     * Handles cases where the uint256 stored in bytes is stored with or without padding.\\n     * @param uint256AsBytes The bytes array representing the uint256 value.\\n     * @return value The uint256 value obtained from the bytes array.\\n     */\\n    function bytesToUint256(bytes memory uint256AsBytes) internal pure returns (uint256) {\\n        uint256 length = uint256AsBytes.length;\\n\\n        if(length > 32) {\\n            revert Errors.Uint256AsBytesLengthExceeds32Bytes(length);\\n        }\\n\\n        if (length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 value;\\n\\n        assembly {\\n            value := mload(add(uint256AsBytes, 32))\\n        }\\n\\n        return value = value >> (8 * (32 - length));\\n    }\\n\\n    function uint256ToBytes(uint256 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n        return b;\\n    }\\n\\n    function uint192ToBytes(uint192 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n        return b;\\n    }\\n\\n    function uint32ToBytes(uint32 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n        return b;\\n    }\\n\\n    function int32ToBytes(int32 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n//        bytes memory expoBytes = new bytes(1);\\n//        if (x < 0) {\\n//            expoBytes[0] = bytes1(uint8(-x)); // Use absolute value, e.g., uint8(8) -> 0x08\\n//        } else {\\n//            expoBytes[0] = bytes1(uint8(x));\\n//        }\\n        assembly { mstore(add(b, 32), x) }\\n        return b;\\n//        return expoBytes;\\n    }\\n}\\n\",\"keccak256\":\"0x6b37c48c3e61545c7cb824d4bb0ee2342f235a3a61485d79f182e3abd4e36f19\",\"license\":\"BUSL-1.1\"},\"contracts/utils/EnumerableValues.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\n/**\\n * @title EnumerableValues\\n * @dev Library to extend the EnumerableSet library with functions to get\\n * valuesAt for a range\\n */\\nlibrary EnumerableValues {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**\\n     * Returns an array of bytes32 values from the given set, starting at the given\\n     * start index and ending before the given end index.\\n     *\\n     * @param set The set to get the values from.\\n     * @param start The starting index.\\n     * @param end The ending index.\\n     * @return An array of bytes32 values.\\n     */\\n    function valuesAt(EnumerableSet.Bytes32Set storage set, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\\n        uint256 max = set.length();\\n        if (end > max) { end = max; }\\n\\n        bytes32[] memory items = new bytes32[](end - start);\\n        for (uint256 i = start; i < end; i++) {\\n            items[i - start] = set.at(i);\\n        }\\n\\n        return items;\\n    }\\n\\n\\n    /**\\n     * Returns an array of address values from the given set, starting at the given\\n     * start index and ending before the given end index.\\n     *\\n     * @param set The set to get the values from.\\n     * @param start The starting index.\\n     * @param end The ending index.\\n     * @return An array of address values.\\n     */\\n    function valuesAt(EnumerableSet.AddressSet storage set, uint256 start, uint256 end) internal view returns (address[] memory) {\\n        uint256 max = set.length();\\n        if (end > max) { end = max; }\\n\\n        address[] memory items = new address[](end - start);\\n        for (uint256 i = start; i < end; i++) {\\n            items[i - start] = set.at(i);\\n        }\\n\\n        return items;\\n    }\\n\\n\\n    /**\\n     * Returns an array of uint256 values from the given set, starting at the given\\n     * start index and ending before the given end index, the item at the end index will not be returned.\\n     *\\n     * @param set The set to get the values from.\\n     * @param start The starting index (inclusive, item at the start index will be returned).\\n     * @param end The ending index (exclusive, item at the end index will not be returned).\\n     * @return An array of uint256 values.\\n     */\\n    function valuesAt(EnumerableSet.UintSet storage set, uint256 start, uint256 end) internal view returns (uint256[] memory) {\\n        if (start >= set.length()) {\\n            return new uint256[](0);\\n        }\\n\\n        uint256 max = set.length();\\n        if (end > max) { end = max; }\\n\\n        uint256[] memory items = new uint256[](end - start);\\n        for (uint256 i = start; i < end; i++) {\\n            items[i - start] = set.at(i);\\n        }\\n\\n        return items;\\n    }\\n}\\n\",\"keccak256\":\"0x1e525ad5645bc649551fa3a7d000af1cec96221d7fe1cdc17cedaf942b018f0d\",\"license\":\"BUSL-1.1\"},\"contracts/utils/StringUtils.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary StringUtils {\\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\n    }\\n}\\n\",\"keccak256\":\"0xd9f72f3739ba7274dbad085fd196e408c1bbcdf62997813dc34a890ccfacc16a\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x611024610039600b82828239805160001a607314602c57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c8063bf44f15a1461003a575b600080fd5b81801561004657600080fd5b5061005a61005536600461070c565b61006c565b60405190815260200160405180910390f35b60008181036100c05760405163a8c278dd60e01b815260206004820152601a60248201527906465706f73697420706172616d73206c656e67746820697320360341b60448201526064015b60405180910390fd5b6100c985610208565b6100d284610232565b6000805b838110156101fc5760008585838181106100f2576100f26107c3565b90506040020180360381019061010891906107ef565b90506101178160000151610279565b806020015160000361013c576040516301a2868b60e31b815260040160405180910390fd5b60008a6001600160a01b031663340dbab361015c84600001518c8c6102a0565b60208501516040516001600160e01b031960e085901b168152600481019290925260248201526044016020604051808303816000875af11580156101a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101c89190610856565b90508160200151846101da919061086f565b93506101f28a83600001518b8b866020015186610333565b50506001016100d6565b50979650505050505050565b6001600160a01b03811661022f5760405163066f53b160e01b815260040160405180910390fd5b50565b8060000361022f5760405163a8c278dd60e01b81526020600482015260136024820152720646973747269627574696f6e4964206973203606c1b60448201526064016100b7565b6001600160a01b03811661022f57604051636eb80b5160e11b815260040160405180910390fd5b60006040516020016102dc9060208082526016908201527510d31052535050931157d195539114d7d05353d5539560521b604082015260600190565b60408051808303601f190181528282528051602091820120818401526001600160a01b03968716838301529490951660608201526080808201939093528451808203909301835260a0019093528051910120919050565b61033b610606565b80516103489060026104e5565b6040805180820190915260078152661858d8dbdd5b9d60ca1b60208201528151610375916000908961054a565b6040805180820190915260058152643a37b5b2b760d91b602082015281516103a0916001908861054a565b60208101516103b09060036104e5565b6103f260006040518060400160405280600e81526020016d191a5cdd1c9a589d5d1a5bdb925960921b8152508684602001516105a7909392919063ffffffff16565b61042c600160405180604001604052806006815260200165185b5bdd5b9d60d21b8152508584602001516105a7909392919063ffffffff16565b61046a60026040518060400160405280600a8152602001691b995e1d105b5bdd5b9d60b21b8152508484602001516105a7909392919063ffffffff16565b866001600160a01b03166363d16363610482886105fa565b61048b886105fa565b846040518463ffffffff1660e01b81526004016104aa93929190610ed8565b600060405180830381600087803b1580156104c457600080fd5b505af11580156104d8573d6000803e3d6000fd5b5050505050505050505050565b806001600160401b038111156104fd576104fd6107d9565b60405190808252806020026020018201604052801561054357816020015b60408051808201909152606081526000602082015281526020019060019003908161051b5790505b5090915250565b8184600001518481518110610561576105616107c3565b6020026020010151600001819052508084600001518481518110610587576105876107c3565b6020908102919091018101516001600160a01b0390921691015250505050565b81846000015184815181106105be576105be6107c3565b60200260200101516000018190525080846000015184815181106105e4576105e46107c3565b6020026020010151602001818152505050505050565b6001600160a01b031690565b604080516101208101909152606060e0820181815261010083019190915281908152602001610648604051806040016040528060608152602001606081525090565b815260200161066a604051806040016040528060608152602001606081525090565b815260200161068c604051806040016040528060608152602001606081525090565b81526020016106ae604051806040016040528060608152602001606081525090565b81526020016106d0604051806040016040528060608152602001606081525090565b81526020016106f2604051806040016040528060608152602001606081525090565b905290565b6001600160a01b038116811461022f57600080fd5b60008060008060008060a0878903121561072557600080fd5b8635610730816106f7565b95506020870135610740816106f7565b94506040870135610750816106f7565b93506060870135925060808701356001600160401b0381111561077257600080fd5b8701601f8101891361078357600080fd5b80356001600160401b0381111561079957600080fd5b8960208260061b84010111156107ae57600080fd5b60208201935080925050509295509295509295565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6000604082840312801561080257600080fd5b50604080519081016001600160401b038111828210171561083357634e487b7160e01b600052604160045260246000fd5b6040528235610841816106f7565b81526020928301359281019290925250919050565b60006020828403121561086857600080fd5b5051919050565b8082018082111561089057634e487b7160e01b600052601160045260246000fd5b92915050565b6000815180845260005b818110156108bc576020818501810151868301820152016108a0565b506000602082860101526020601f19601f83011685010191505092915050565b600082825180855260208501945060208160051b8301016020850160005b8381101561098357601f1985840301885281518051604085526109206040860182610896565b6020928301518682038785015280518083529084019360009350909101905b8083101561096a5783516001600160a01b03168252602093840193600193909301929091019061093f565b5060209a8b019a909550939093019250506001016108fa565b50909695505050505050565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610a0957605f1988860301835283518051604087526109e16040880182610896565b6020928301516001600160a01b031697830197909752509384019392909201916001016109bb565b5050505060208301518482036020860152610a2482826108dc565b95945050505050565b600082825180855260208501945060208160051b8301016020850160005b8381101561098357601f198584030188528151805160408552610a716040860182610896565b6020928301518682038785015280518083529084019360009350909101905b80831015610ab35783518252602082019150602084019350600183019250610a90565b5060209a8b019a90955093909301925050600101610a4b565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610b3d57605f198886030183528351805160408752610b1e6040880182610896565b6020928301519783019790975250938401939290920191600101610af8565b5050505060208301518482036020860152610a248282610a2d565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610b3d57605f198886030183528351805160408752610baa6040880182610896565b6020928301519783019790975250938401939290920191600101610b84565b600082825180855260208501945060208160051b8301016020850160005b8381101561098357601f198584030188528151805160408552610c0d6040860182610896565b6020928301518682038785015280518083529084019360009350909101905b80831015610c5157835115158252602082019150602084019350600183019250610c2c565b5060209a8b019a90955093909301925050600101610be7565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610cdd57605f198886030183528351805160408752610cbc6040880182610896565b60209283015115159783019790975250938401939290920191600101610c96565b5050505060208301518482036020860152610a248282610bc9565b600082825180855260208501945060208160051b8301016020850160005b8381101561098357601f198584030188528151805160408552610d3c6040860182610896565b6020928301518682038785015280518083529084019391925081830191600582901b84010160005b82811015610d9557601f19858303018452610d80828751610896565b60209687019694909401939150600101610d64565b508097505050505050602082019150602088019750600181019050610d16565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610e3957605f198886030183528351805160408752610e076040880182610896565b9050602082015191508681036020880152610e228183610896565b965050506020938401939290920191600101610de1565b5050505060208301518482036020860152610a248282610cf8565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610e3957605f198886030183528351805160408752610ea66040880182610896565b9050602082015191508681036020880152610ec18183610896565b965050506020938401939290920191600101610e80565b60808152601360808201527210db185a5b519d5b991cd1195c1bdcda5d1959606a1b60a082015283602082015282604082015260c060608201526000825160e060c0840152610f2b6101a084018261098f565b9050602084015160bf198483030160e0850152610f488282610acc565b915050604084015160bf1984830301610100850152610f678282610b58565b915050606084015160bf1984830301610120850152610f868282610c6a565b915050608084015160bf1984830301610140850152610fa58282610acc565b91505060a084015160bf1984830301610160850152610fc48282610db5565b91505060c084015160bf1984830301610180850152610fe38282610e54565b97965050505050505056fea2646970667358221220aeec61b2ec81316045af0fa300fa596efdbff9335ad07fdb6b8bce262a054f4b64736f6c634300081d0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c8063bf44f15a1461003a575b600080fd5b81801561004657600080fd5b5061005a61005536600461070c565b61006c565b60405190815260200160405180910390f35b60008181036100c05760405163a8c278dd60e01b815260206004820152601a60248201527906465706f73697420706172616d73206c656e67746820697320360341b60448201526064015b60405180910390fd5b6100c985610208565b6100d284610232565b6000805b838110156101fc5760008585838181106100f2576100f26107c3565b90506040020180360381019061010891906107ef565b90506101178160000151610279565b806020015160000361013c576040516301a2868b60e31b815260040160405180910390fd5b60008a6001600160a01b031663340dbab361015c84600001518c8c6102a0565b60208501516040516001600160e01b031960e085901b168152600481019290925260248201526044016020604051808303816000875af11580156101a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101c89190610856565b90508160200151846101da919061086f565b93506101f28a83600001518b8b866020015186610333565b50506001016100d6565b50979650505050505050565b6001600160a01b03811661022f5760405163066f53b160e01b815260040160405180910390fd5b50565b8060000361022f5760405163a8c278dd60e01b81526020600482015260136024820152720646973747269627574696f6e4964206973203606c1b60448201526064016100b7565b6001600160a01b03811661022f57604051636eb80b5160e11b815260040160405180910390fd5b60006040516020016102dc9060208082526016908201527510d31052535050931157d195539114d7d05353d5539560521b604082015260600190565b60408051808303601f190181528282528051602091820120818401526001600160a01b03968716838301529490951660608201526080808201939093528451808203909301835260a0019093528051910120919050565b61033b610606565b80516103489060026104e5565b6040805180820190915260078152661858d8dbdd5b9d60ca1b60208201528151610375916000908961054a565b6040805180820190915260058152643a37b5b2b760d91b602082015281516103a0916001908861054a565b60208101516103b09060036104e5565b6103f260006040518060400160405280600e81526020016d191a5cdd1c9a589d5d1a5bdb925960921b8152508684602001516105a7909392919063ffffffff16565b61042c600160405180604001604052806006815260200165185b5bdd5b9d60d21b8152508584602001516105a7909392919063ffffffff16565b61046a60026040518060400160405280600a8152602001691b995e1d105b5bdd5b9d60b21b8152508484602001516105a7909392919063ffffffff16565b866001600160a01b03166363d16363610482886105fa565b61048b886105fa565b846040518463ffffffff1660e01b81526004016104aa93929190610ed8565b600060405180830381600087803b1580156104c457600080fd5b505af11580156104d8573d6000803e3d6000fd5b5050505050505050505050565b806001600160401b038111156104fd576104fd6107d9565b60405190808252806020026020018201604052801561054357816020015b60408051808201909152606081526000602082015281526020019060019003908161051b5790505b5090915250565b8184600001518481518110610561576105616107c3565b6020026020010151600001819052508084600001518481518110610587576105876107c3565b6020908102919091018101516001600160a01b0390921691015250505050565b81846000015184815181106105be576105be6107c3565b60200260200101516000018190525080846000015184815181106105e4576105e46107c3565b6020026020010151602001818152505050505050565b6001600160a01b031690565b604080516101208101909152606060e0820181815261010083019190915281908152602001610648604051806040016040528060608152602001606081525090565b815260200161066a604051806040016040528060608152602001606081525090565b815260200161068c604051806040016040528060608152602001606081525090565b81526020016106ae604051806040016040528060608152602001606081525090565b81526020016106d0604051806040016040528060608152602001606081525090565b81526020016106f2604051806040016040528060608152602001606081525090565b905290565b6001600160a01b038116811461022f57600080fd5b60008060008060008060a0878903121561072557600080fd5b8635610730816106f7565b95506020870135610740816106f7565b94506040870135610750816106f7565b93506060870135925060808701356001600160401b0381111561077257600080fd5b8701601f8101891361078357600080fd5b80356001600160401b0381111561079957600080fd5b8960208260061b84010111156107ae57600080fd5b60208201935080925050509295509295509295565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6000604082840312801561080257600080fd5b50604080519081016001600160401b038111828210171561083357634e487b7160e01b600052604160045260246000fd5b6040528235610841816106f7565b81526020928301359281019290925250919050565b60006020828403121561086857600080fd5b5051919050565b8082018082111561089057634e487b7160e01b600052601160045260246000fd5b92915050565b6000815180845260005b818110156108bc576020818501810151868301820152016108a0565b506000602082860101526020601f19601f83011685010191505092915050565b600082825180855260208501945060208160051b8301016020850160005b8381101561098357601f1985840301885281518051604085526109206040860182610896565b6020928301518682038785015280518083529084019360009350909101905b8083101561096a5783516001600160a01b03168252602093840193600193909301929091019061093f565b5060209a8b019a909550939093019250506001016108fa565b50909695505050505050565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610a0957605f1988860301835283518051604087526109e16040880182610896565b6020928301516001600160a01b031697830197909752509384019392909201916001016109bb565b5050505060208301518482036020860152610a2482826108dc565b95945050505050565b600082825180855260208501945060208160051b8301016020850160005b8381101561098357601f198584030188528151805160408552610a716040860182610896565b6020928301518682038785015280518083529084019360009350909101905b80831015610ab35783518252602082019150602084019350600183019250610a90565b5060209a8b019a90955093909301925050600101610a4b565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610b3d57605f198886030183528351805160408752610b1e6040880182610896565b6020928301519783019790975250938401939290920191600101610af8565b5050505060208301518482036020860152610a248282610a2d565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610b3d57605f198886030183528351805160408752610baa6040880182610896565b6020928301519783019790975250938401939290920191600101610b84565b600082825180855260208501945060208160051b8301016020850160005b8381101561098357601f198584030188528151805160408552610c0d6040860182610896565b6020928301518682038785015280518083529084019360009350909101905b80831015610c5157835115158252602082019150602084019350600183019250610c2c565b5060209a8b019a90955093909301925050600101610be7565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610cdd57605f198886030183528351805160408752610cbc6040880182610896565b60209283015115159783019790975250938401939290920191600101610c96565b5050505060208301518482036020860152610a248282610bc9565b600082825180855260208501945060208160051b8301016020850160005b8381101561098357601f198584030188528151805160408552610d3c6040860182610896565b6020928301518682038785015280518083529084019391925081830191600582901b84010160005b82811015610d9557601f19858303018452610d80828751610896565b60209687019694909401939150600101610d64565b508097505050505050602082019150602088019750600181019050610d16565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610e3957605f198886030183528351805160408752610e076040880182610896565b9050602082015191508681036020880152610e228183610896565b965050506020938401939290920191600101610de1565b5050505060208301518482036020860152610a248282610cf8565b60006040830182516040855281815180845260608701915060608160051b880101935060208301925060005b81811015610e3957605f198886030183528351805160408752610ea66040880182610896565b9050602082015191508681036020880152610ec18183610896565b965050506020938401939290920191600101610e80565b60808152601360808201527210db185a5b519d5b991cd1195c1bdcda5d1959606a1b60a082015283602082015282604082015260c060608201526000825160e060c0840152610f2b6101a084018261098f565b9050602084015160bf198483030160e0850152610f488282610acc565b915050604084015160bf1984830301610100850152610f678282610b58565b915050606084015160bf1984830301610120850152610f868282610c6a565b915050608084015160bf1984830301610140850152610fa58282610acc565b91505060a084015160bf1984830301610160850152610fc48282610db5565b91505060c084015160bf1984830301610180850152610fe38282610e54565b97965050505050505056fea2646970667358221220aeec61b2ec81316045af0fa300fa596efdbff9335ad07fdb6b8bce262a054f4b64736f6c634300081d0033",
  "libraries": {},
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}