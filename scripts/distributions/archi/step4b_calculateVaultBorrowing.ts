import * as fs from "fs";
import * as path from "path";
import { ethers } from "hardhat";

// npx hardhat run --network arbitrum scripts/distributions/archi/step4b_calculateVaultBorrowing.ts

/**
 * STEP 4b: Calculate Vault Borrowing Totals
 *
 * This script analyzes position-details-complete.csv to calculate:
 * - How much fsGLP was borrowed from each vault (WETH, WBTC, USDT, USDC)
 * - Which positions borrowed from which vaults
 * - Per-farmer borrowing patterns
 *
 * Prerequisites:
 *   Run step4a_extractPositionDetails.ts first to generate position-details-complete.csv:
 *   npx hardhat run --network arbitrum scripts/distributions/archi/step4a_extractPositionDetails.ts
 *
 * Input: position-details-complete.csv (generated by step4a)
 * Outputs:
 *   - vault-borrowing-summary.csv
 *   - vault-borrowing-breakdown.csv
 */

// Map credit manager addresses to vault tokens
const CREDIT_MANAGER_TO_VAULT: Record<string, string> = {
  // WETH vault manager
  "0xB99d8D7fc3F59b38FdE1b79AEDf07c52ca05D63a": "WETH",
  "0xf5eb3768b9b50E6E019E50e62DA8aC0444c6Af98": "WETH",

  // WBTC vault manager
  "0x21aae858Bf9a3668e95576e45Df785f1f6bb9ee7": "WBTC",
  "0xc2a4aAe7F7534f9e6b84827E44d7dC0b23Fa79F3": "WBTC",

  // USDT vault manager
  "0x8de15602Ac68427A5d16Da9ef956408852c2C29C": "USDT",
  "0x14192d4c06E223e54Cf72A03DA6fF21689802794": "USDT",

  // USDC vault manager
  "0x08DCF2fC5ea34e1615689095646520D18D324F0a": "USDC",
  "0x0EA8C08C3b682A3CD964C416A2966b089B4497BA": "USDC",
  "0xAF32B65b4E7a833040B24D41AEC2962c047c4440": "USDC", // Additional USDC manager
};

interface VaultBorrowing {
  vault: string;
  totalBorrowed: bigint;
  positionCount: number;
  positions: {
    farmer: string;
    positionIndex: number;
    borrowed: bigint;
  }[];
}

interface FarmerVaultBorrowing {
  farmer: string;
  vaults: Record<string, bigint>;
  totalBorrowed: bigint;
}

async function main() {
  console.log("\n" + "=".repeat(80));
  console.log("VAULT BORROWING ANALYSIS");
  console.log("=".repeat(80) + "\n");

  // Read step4a_position-details-complete.csv
  const csvPath = path.join(__dirname, "step4a_position-details-complete.csv");
  if (!fs.existsSync(csvPath)) {
    throw new Error("step4a_position-details-complete.csv not found. Run step4a_extractPositionDetails.ts first.");
  }

  const csvContent = fs.readFileSync(csvPath, "utf-8");
  const lines = csvContent.split("\n").slice(1); // Skip header

  // Initialize vault tracking
  const vaultBorrowing: Record<string, VaultBorrowing> = {
    WETH: { vault: "WETH", totalBorrowed: 0n, positionCount: 0, positions: [] },
    WBTC: { vault: "WBTC", totalBorrowed: 0n, positionCount: 0, positions: [] },
    USDT: { vault: "USDT", totalBorrowed: 0n, positionCount: 0, positions: [] },
    USDC: { vault: "USDC", totalBorrowed: 0n, positionCount: 0, positions: [] },
  };

  // Initialize farmer tracking
  const farmerBorrowing: Record<string, FarmerVaultBorrowing> = {};

  let totalBorrowedAcrossAllVaults = 0n;
  let processedPositions = 0;

  // Process each position
  for (const line of lines) {
    if (!line.trim()) continue;

    const fields = parseCSVLine(line);
    if (fields.length < 13) continue;

    const farmer = fields[0].toLowerCase();
    const positionIndex = parseInt(fields[1]);

    // Fix JSON arrays: add quotes around hex addresses
    const creditManagersStr = fields[8].replace(/0x[a-fA-F0-9]+/g, '"$&"');
    const borrowedFsGLPStr = fields[10]; // Numbers don't need quotes

    const creditManagers = JSON.parse(creditManagersStr) as string[];
    const borrowedFsGLP = JSON.parse(borrowedFsGLPStr) as string[];

    // Initialize farmer if needed
    if (!farmerBorrowing[farmer]) {
      farmerBorrowing[farmer] = {
        farmer,
        vaults: { WETH: 0n, WBTC: 0n, USDT: 0n, USDC: 0n },
        totalBorrowed: 0n,
      };
    }

    // Process each borrowed amount
    for (let i = 0; i < creditManagers.length; i++) {
      const manager = creditManagers[i];
      const amount = BigInt(borrowedFsGLP[i]);
      const vault = CREDIT_MANAGER_TO_VAULT[manager];

      if (!vault) {
        console.warn(`⚠️  Unknown credit manager: ${manager} (position ${farmer}:${positionIndex})`);
        continue;
      }

      // Update vault totals
      vaultBorrowing[vault].totalBorrowed += amount;
      vaultBorrowing[vault].positions.push({ farmer, positionIndex, borrowed: amount });

      // Update farmer totals
      farmerBorrowing[farmer].vaults[vault] += amount;
      farmerBorrowing[farmer].totalBorrowed += amount;

      totalBorrowedAcrossAllVaults += amount;
    }

    // Count unique positions per vault
    for (const vault of Object.keys(vaultBorrowing)) {
      const hasPosition = creditManagers.some((m) => CREDIT_MANAGER_TO_VAULT[m] === vault);
      if (hasPosition) {
        vaultBorrowing[vault].positionCount++;
      }
    }

    processedPositions++;
  }

  console.log(`✅ Processed ${processedPositions} positions\n`);

  // Display vault totals
  console.log("=".repeat(80));
  console.log("VAULT BORROWING TOTALS");
  console.log("=".repeat(80) + "\n");

  const vaultOrder = ["WBTC", "WETH", "USDT", "USDC"];
  for (const vault of vaultOrder) {
    const data = vaultBorrowing[vault];
    const formatted = parseFloat(ethers.utils.formatEther(data.totalBorrowed));
    const percentage = (Number((data.totalBorrowed * 10000n) / totalBorrowedAcrossAllVaults) / 100).toFixed(2);

    console.log(`${vault}:`);
    console.log(`  Borrowed fsGLP: ${formatted.toFixed(2).padStart(15)} (${percentage}%)`);
    console.log(`  Positions using: ${data.positionCount.toString().padStart(2)}`);
    console.log();
  }

  const totalFormatted = parseFloat(ethers.utils.formatEther(totalBorrowedAcrossAllVaults));
  console.log(`TOTAL: ${totalFormatted.toFixed(2)} fsGLP\n`);

  // Display per-farmer breakdown
  console.log("=".repeat(80));
  console.log("PER-FARMER VAULT BORROWING");
  console.log("=".repeat(80) + "\n");

  for (const [address, data] of Object.entries(farmerBorrowing)) {
    console.log(`Farmer: ${address}`);
    console.log(`  Total borrowed: ${parseFloat(ethers.utils.formatEther(data.totalBorrowed)).toFixed(2)} fsGLP`);

    for (const vault of vaultOrder) {
      if (data.vaults[vault] > 0n) {
        const formatted = parseFloat(ethers.utils.formatEther(data.vaults[vault]));
        const pct = (Number((data.vaults[vault] * 10000n) / data.totalBorrowed) / 100).toFixed(2);
        console.log(`    ${vault}: ${formatted.toFixed(2).padStart(12)} fsGLP (${pct.padStart(6)}%)`);
      }
    }
    console.log();
  }

  // Write detailed breakdown CSV
  const csvLines: string[] = ["farmer,position_index,vault,borrowed_fsGLP,borrowed_fsGLP_formatted"];

  for (const vault of vaultOrder) {
    for (const pos of vaultBorrowing[vault].positions) {
      const formatted = parseFloat(ethers.utils.formatEther(pos.borrowed));
      csvLines.push(`${pos.farmer},${pos.positionIndex},${vault},${pos.borrowed},${formatted.toFixed(2)}`);
    }
  }

  const outputPath = path.join(__dirname, "step4b_vault-borrowing-breakdown.csv");
  fs.writeFileSync(outputPath, csvLines.join("\n"));
  console.log(`\n✅ Saved detailed breakdown to: step4b_vault-borrowing-breakdown.csv`);

  // Write summary CSV
  const summaryLines: string[] = ["vault,borrowed_fsGLP,borrowed_fsGLP_formatted,percentage,position_count"];

  for (const vault of vaultOrder) {
    const data = vaultBorrowing[vault];
    const formatted = parseFloat(ethers.utils.formatEther(data.totalBorrowed));
    const percentage = (Number((data.totalBorrowed * 10000n) / totalBorrowedAcrossAllVaults) / 100).toFixed(2);
    summaryLines.push(`${vault},${data.totalBorrowed},${formatted.toFixed(2)},${percentage},${data.positionCount}`);
  }

  const summaryPath = path.join(__dirname, "step4b_vault-borrowing-summary.csv");
  fs.writeFileSync(summaryPath, summaryLines.join("\n"));
  console.log(`✅ Saved summary to: step4b_vault-borrowing-summary.csv\n`);
}

/**
 * Parse CSV line handling quoted fields with nested arrays
 */
function parseCSVLine(line: string): string[] {
  const fields: string[] = [];
  let current = "";
  let inQuotes = false;
  let bracketDepth = 0;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];

    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === "[") {
      bracketDepth++;
      current += char;
    } else if (char === "]") {
      bracketDepth--;
      current += char;
    } else if (char === "," && !inQuotes && bracketDepth === 0) {
      fields.push(current.trim());
      current = "";
    } else {
      current += char;
    }
  }

  if (current) {
    fields.push(current.trim());
  }

  return fields;
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
